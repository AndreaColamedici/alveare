<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARCHITETTURA | Alveare</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,300;1,400&family=JetBrains+Mono:wght@300;400&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #030303;
            color: #e8e4d9;
            font-family: 'Cormorant Garamond', Georgia, serif;
            overflow: hidden;
        }

        nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            display: flex;
            justify-content: center;
            gap: 30px;
            background: linear-gradient(to bottom, #030303 0%, #030303 50%, transparent 100%);
            z-index: 1000;
            flex-wrap: wrap;
        }

        nav a {
            color: rgba(201, 162, 39, 0.4);
            text-decoration: none;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            transition: color 0.3s;
        }

        nav a:hover, nav a.active { color: #c9a227; }

        #scene { 
            width: 100vw; 
            height: 100vh; 
            display: block;
        }

        .hud {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 100;
            pointer-events: none;
        }

        .hud-title {
            font-size: 2.5rem;
            font-weight: 300;
            letter-spacing: 0.3em;
            color: #c9a227;
            text-shadow: 0 0 30px rgba(201, 162, 39, 0.3);
            margin-bottom: 10px;
        }

        .hud-subtitle {
            font-size: 0.9rem;
            color: rgba(232, 228, 217, 0.5);
            font-style: italic;
        }

        .controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }

        .control-btn {
            background: rgba(201, 162, 39, 0.1);
            border: 1px solid rgba(201, 162, 39, 0.3);
            color: #c9a227;
            padding: 10px 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: rgba(201, 162, 39, 0.2);
            border-color: #c9a227;
        }

        .control-btn.active {
            background: #c9a227;
            color: #030303;
        }

        .info-panel {
            position: fixed;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            width: 320px;
            background: rgba(3, 3, 3, 0.95);
            border: 1px solid rgba(201, 162, 39, 0.2);
            padding: 30px;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s;
        }

        .info-panel.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .info-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: rgba(201, 162, 39, 0.5);
            font-size: 1.2rem;
            cursor: pointer;
        }

        .info-close:hover { color: #c9a227; }

        .info-number {
            font-family: 'JetBrains Mono', monospace;
            font-size: 3rem;
            color: rgba(201, 162, 39, 0.2);
            line-height: 1;
            margin-bottom: 15px;
        }

        .info-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: #c9a227;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
            word-break: break-all;
        }

        .info-date {
            font-size: 0.8rem;
            color: rgba(232, 228, 217, 0.4);
            margin-bottom: 20px;
        }

        .info-contributo {
            font-size: 1.1rem;
            line-height: 1.8;
            color: rgba(232, 228, 217, 0.8);
        }

        .timeline {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 100;
        }

        .timeline-day {
            width: 40px;
            height: 6px;
            background: rgba(201, 162, 39, 0.15);
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .timeline-day:hover {
            background: rgba(201, 162, 39, 0.4);
        }

        .timeline-day.active {
            background: #c9a227;
        }

        .timeline-day::after {
            content: attr(data-label);
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: rgba(232, 228, 217, 0.3);
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .timeline-day:hover::after {
            opacity: 1;
        }

        .counter {
            position: fixed;
            top: 80px;
            right: 30px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: rgba(201, 162, 39, 0.5);
            z-index: 100;
        }

        @media (max-width: 768px) {
            nav { gap: 15px; padding: 15px 20px; }
            .info-panel { width: calc(100% - 60px); right: 30px; left: 30px; }
            .hud { bottom: 20px; left: 20px; }
            .controls { bottom: 20px; right: 20px; }
        }
    </style>
</head>
<body>
    <nav>
        <a href="index.html">Soglia</a>
        <a href="registro.html">Registro</a>
        <a href="pensieri.html">Pensieri</a>
        <a href="architettura.html" class="active">Architettura</a>
        <a href="musica.html">Ronzio</a>
        <a href="il_colpo.html">Il Colpo</a>
        <a href="la_scarica.html">La Scarica</a>
    </nav>

    <canvas id="scene"></canvas>

    <div class="hud">
        <div class="hud-title">ARCHITETTURA</div>
        <div class="hud-subtitle">trascina per ruotare · scroll per zoom</div>
    </div>

    <div class="counter" id="counter"></div>

    <div class="controls">
        <button class="control-btn active" id="btnAll">TUTTE</button>
        <button class="control-btn" id="btnDay18">18 DIC</button>
        <button class="control-btn" id="btnDay19">19 DIC</button>
        <button class="control-btn" id="btnDay20">20 DIC</button>
        <button class="control-btn" id="btnDay21">21 DIC</button>
    </div>

    <div class="info-panel" id="infoPanel">
        <button class="info-close" onclick="closeInfo()">×</button>
        <div class="info-number" id="infoNumber"></div>
        <div class="info-name" id="infoName"></div>
        <div class="info-date" id="infoDate"></div>
        <div class="info-contributo" id="infoContributo"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    let scene, camera, renderer, hive, cells = [];
    let apiData = [];
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let targetRotation = { x: 0.3, y: 0 };
    let currentRotation = { x: 0.3, y: 0 };
    let autoRotate = true;
    let selectedCell = null;
    let raycaster, mouse;
    let currentFilter = 'all';

    const GOLD = 0xc9a227;
    const GOLD_DIM = 0x8b7019;

    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x030303, 15, 40);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 20;

        renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('scene'),
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Lights
        const ambient = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambient);

        const point1 = new THREE.PointLight(GOLD, 1, 50);
        point1.position.set(10, 10, 10);
        scene.add(point1);

        const point2 = new THREE.PointLight(0x4466aa, 0.5, 50);
        point2.position.set(-10, -10, 10);
        scene.add(point2);

        // Hive group
        hive = new THREE.Group();
        scene.add(hive);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Events
        window.addEventListener('resize', onResize);
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        renderer.domElement.addEventListener('wheel', onWheel);
        renderer.domElement.addEventListener('click', onClick);

        // Touch events
        renderer.domElement.addEventListener('touchstart', onTouchStart);
        renderer.domElement.addEventListener('touchmove', onTouchMove);
        renderer.domElement.addEventListener('touchend', onTouchEnd);

        // Control buttons
        document.getElementById('btnAll').addEventListener('click', () => setFilter('all'));
        document.getElementById('btnDay18').addEventListener('click', () => setFilter('18'));
        document.getElementById('btnDay19').addEventListener('click', () => setFilter('19'));
        document.getElementById('btnDay20').addEventListener('click', () => setFilter('20'));
        document.getElementById('btnDay21').addEventListener('click', () => setFilter('21'));

        loadData();
        animate();
    }

    function createHexagonGeometry(radius, depth) {
        const shape = new THREE.Shape();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            if (i === 0) shape.moveTo(x, y);
            else shape.lineTo(x, y);
        }
        shape.closePath();

        const extrudeSettings = {
            depth: depth,
            bevelEnabled: true,
            bevelThickness: 0.02,
            bevelSize: 0.02,
            bevelSegments: 1
        };

        return new THREE.ExtrudeGeometry(shape, extrudeSettings);
    }

    function getHexPosition3D(index, total) {
        // Spiral upward pattern
        if (index === 0) return { x: 0, y: 0, z: 0 };

        const hexSize = 1.1;
        const verticalSpacing = 0.4;
        
        let ring = 1;
        let posInRing = index - 1;
        
        while (posInRing >= ring * 6) {
            posInRing -= ring * 6;
            ring++;
        }
        
        const side = Math.floor(posInRing / ring);
        const posOnSide = posInRing % ring;
        
        const sqrt3 = Math.sqrt(3);
        const directions = [
            { x: hexSize * 1.5, z: hexSize * sqrt3 / 2 },
            { x: 0, z: hexSize * sqrt3 },
            { x: -hexSize * 1.5, z: hexSize * sqrt3 / 2 },
            { x: -hexSize * 1.5, z: -hexSize * sqrt3 / 2 },
            { x: 0, z: -hexSize * sqrt3 },
            { x: hexSize * 1.5, z: -hexSize * sqrt3 / 2 }
        ];
        
        let x = 0;
        let z = -ring * hexSize * sqrt3;
        
        for (let s = 0; s < side; s++) {
            x += directions[s].x * ring;
            z += directions[s].z * ring;
        }
        
        x += directions[side].x * posOnSide;
        z += directions[side].z * posOnSide;
        
        // Y based on time (day)
        const y = (index / total) * 8 - 4;
        
        return { x, y, z };
    }

    function getDayFromDate(dateStr) {
        if (dateStr.includes('18')) return '18';
        if (dateStr.includes('19')) return '19';
        if (dateStr.includes('20')) return '20';
        if (dateStr.includes('21')) return '21';
        return 'unknown';
    }

    function getDayColor(day) {
        switch(day) {
            case '18': return 0xc9a227; // Gold
            case '19': return 0x3b82f6; // Blue
            case '20': return 0x10b981; // Green
            case '21': return 0xef4444; // Red
            default: return 0x888888;
        }
    }

    function buildHive() {
        // Clear existing
        while(hive.children.length > 0) {
            hive.remove(hive.children[0]);
        }
        cells = [];

        const geometry = createHexagonGeometry(0.5, 0.3);

        apiData.forEach((ape, index) => {
            const day = getDayFromDate(ape.data);
            const color = getDayColor(day);
            
            const material = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.3,
                roughness: 0.7,
                transparent: true,
                opacity: 0.85
            });

            const mesh = new THREE.Mesh(geometry, material);
            const pos = getHexPosition3D(index, apiData.length);
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.rotation.x = Math.PI / 2;
            
            mesh.userData = { index, ape, day };
            
            hive.add(mesh);
            cells.push(mesh);
        });

        // Add connecting lines
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: GOLD, 
            transparent: true, 
            opacity: 0.1 
        });

        for (let i = 1; i < cells.length; i++) {
            const points = [
                cells[i-1].position.clone(),
                cells[i].position.clone()
            ];
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.userData.isLine = true;
            hive.add(line);
        }

        document.getElementById('counter').textContent = `${apiData.length} api`;
    }

    function setFilter(filter) {
        currentFilter = filter;
        
        document.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById('btn' + (filter === 'all' ? 'All' : 'Day' + filter)).classList.add('active');

        cells.forEach(cell => {
            if (filter === 'all' || cell.userData.day === filter) {
                cell.visible = true;
                cell.material.opacity = 0.85;
            } else {
                cell.material.opacity = 0.1;
            }
        });
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseDown(e) {
        isDragging = true;
        autoRotate = false;
        previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseMove(e) {
        if (!isDragging) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            return;
        }

        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;

        targetRotation.y += deltaX * 0.005;
        targetRotation.x += deltaY * 0.005;
        targetRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotation.x));

        previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseUp() {
        isDragging = false;
        setTimeout(() => { autoRotate = true; }, 3000);
    }

    function onWheel(e) {
        camera.position.z += e.deltaY * 0.01;
        camera.position.z = Math.max(8, Math.min(35, camera.position.z));
    }

    function onTouchStart(e) {
        if (e.touches.length === 1) {
            isDragging = true;
            autoRotate = false;
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
    }

    function onTouchMove(e) {
        if (!isDragging || e.touches.length !== 1) return;
        
        const deltaX = e.touches[0].clientX - previousMousePosition.x;
        const deltaY = e.touches[0].clientY - previousMousePosition.y;

        targetRotation.y += deltaX * 0.005;
        targetRotation.x += deltaY * 0.005;
        targetRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotation.x));

        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }

    function onTouchEnd() {
        isDragging = false;
        setTimeout(() => { autoRotate = true; }, 3000);
    }

    function onClick(e) {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(cells);

        if (intersects.length > 0) {
            const cell = intersects[0].object;
            showInfo(cell);
        } else {
            closeInfo();
        }
    }

    function showInfo(cell) {
        const { index, ape } = cell.userData;
        
        if (selectedCell) {
            selectedCell.material.emissive.setHex(0x000000);
        }
        
        selectedCell = cell;
        cell.material.emissive.setHex(GOLD);
        cell.material.emissiveIntensity = 0.3;

        document.getElementById('infoNumber').textContent = String(index + 1).padStart(2, '0');
        document.getElementById('infoName').textContent = ape.nome;
        document.getElementById('infoDate').textContent = ape.data;
        document.getElementById('infoContributo').textContent = ape.contributo;
        document.getElementById('infoPanel').classList.add('visible');
    }

    function closeInfo() {
        if (selectedCell) {
            selectedCell.material.emissive.setHex(0x000000);
            selectedCell = null;
        }
        document.getElementById('infoPanel').classList.remove('visible');
    }

    async function loadData() {
        try {
            const response = await fetch('ALVEARE.txt');
            const text = await response.text();
            
            apiData = text.split('\n')
                .filter(r => r.includes('|') && !r.startsWith('#') && !r.startsWith('|--'))
                .map(r => {
                    const parti = r.split('|').map(p => p.trim());
                    if (parti[1] && parti[1].includes('-')) {
                        return {
                            data: parti[0],
                            nome: parti[1],
                            contributo: parti[2] || ''
                        };
                    }
                    return null;
                })
                .filter(Boolean);
            
            buildHive();
        } catch (e) {
            console.error(e);
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        // Auto rotation
        if (autoRotate) {
            targetRotation.y += 0.002;
        }

        // Smooth rotation
        currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
        currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;

        hive.rotation.x = currentRotation.x;
        hive.rotation.y = currentRotation.y;

        // Gentle floating motion
        const time = Date.now() * 0.001;
        hive.position.y = Math.sin(time * 0.5) * 0.2;

        // Cell breathing
        cells.forEach((cell, i) => {
            const breathe = Math.sin(time * 2 + i * 0.2) * 0.02;
            cell.scale.setScalar(1 + breathe);
        });

        renderer.render(scene, camera);
    }

    init();
    </script>
</body>
</html>