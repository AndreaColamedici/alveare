<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARCHITETTURA | Alveare</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,300;1,400&family=JetBrains+Mono:wght@300;400&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #020202;
            color: #e8e4d9;
            font-family: 'Cormorant Garamond', Georgia, serif;
            overflow: hidden;
        }

        nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            display: flex;
            justify-content: center;
            gap: 30px;
            background: linear-gradient(to bottom, rgba(2,2,2,1) 0%, rgba(2,2,2,0.8) 50%, transparent 100%);
            z-index: 1000;
            flex-wrap: wrap;
        }

        nav a {
            color: rgba(201, 162, 39, 0.4);
            text-decoration: none;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            transition: color 0.3s;
        }

        nav a:hover, nav a.active { color: #c9a227; }

        #scene { 
            width: 100vw; 
            height: 100vh; 
            display: block;
        }

        .hud {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 100;
            pointer-events: none;
        }

        .hud-title {
            font-size: 2.2rem;
            font-weight: 300;
            letter-spacing: 0.3em;
            color: #c9a227;
            text-shadow: 0 0 40px rgba(201, 162, 39, 0.4);
            margin-bottom: 8px;
        }

        .hud-subtitle {
            font-size: 0.85rem;
            color: rgba(232, 228, 217, 0.4);
            font-style: italic;
        }

        .pulse-indicator {
            position: fixed;
            bottom: 35px;
            left: 220px;
            width: 8px;
            height: 8px;
            background: #c9a227;
            border-radius: 50%;
            animation: heartbeat 1.5s ease-in-out infinite;
            box-shadow: 0 0 20px #c9a227;
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }

        .controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
        }

        .control-btn {
            background: rgba(201, 162, 39, 0.08);
            border: 1px solid rgba(201, 162, 39, 0.25);
            color: rgba(201, 162, 39, 0.7);
            padding: 8px 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: rgba(201, 162, 39, 0.15);
            border-color: rgba(201, 162, 39, 0.5);
            color: #c9a227;
        }

        .control-btn.active {
            background: #c9a227;
            color: #020202;
            border-color: #c9a227;
        }

        .info-panel {
            position: fixed;
            top: 50%;
            right: 30px;
            transform: translateY(-50%) translateX(20px);
            width: 300px;
            background: rgba(2, 2, 2, 0.97);
            border: 1px solid rgba(201, 162, 39, 0.15);
            padding: 25px;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .info-panel.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(-50%) translateX(0);
        }

        .info-close {
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            color: rgba(201, 162, 39, 0.4);
            font-size: 1.1rem;
            cursor: pointer;
            transition: color 0.3s;
        }

        .info-close:hover { color: #c9a227; }

        .info-number {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2.5rem;
            color: rgba(201, 162, 39, 0.15);
            line-height: 1;
            margin-bottom: 12px;
        }

        .info-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: #c9a227;
            letter-spacing: 0.05em;
            margin-bottom: 6px;
            word-break: break-all;
        }

        .info-date {
            font-size: 0.75rem;
            color: rgba(232, 228, 217, 0.35);
            margin-bottom: 18px;
        }

        .info-contributo {
            font-size: 1.05rem;
            line-height: 1.8;
            color: rgba(232, 228, 217, 0.75);
        }

        .info-connections {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(201, 162, 39, 0.1);
        }

        .info-connections-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: rgba(201, 162, 39, 0.5);
            letter-spacing: 0.15em;
            margin-bottom: 10px;
        }

        .info-connection-item {
            font-size: 0.75rem;
            color: rgba(232, 228, 217, 0.5);
            margin-bottom: 5px;
            cursor: pointer;
            transition: color 0.3s;
        }

        .info-connection-item:hover {
            color: #c9a227;
        }

        .counter {
            position: fixed;
            top: 80px;
            right: 30px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: rgba(201, 162, 39, 0.4);
            z-index: 100;
        }

        .time-label {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            letter-spacing: 0.2em;
            color: rgba(201, 162, 39, 0.3);
            z-index: 100;
            pointer-events: none;
        }

        .time-label.top { top: 80px; }
        .time-label.bottom { bottom: 100px; }

        @media (max-width: 768px) {
            nav { gap: 15px; padding: 15px 20px; }
            .info-panel { 
                width: calc(100% - 40px); 
                right: 20px; 
                left: 20px; 
                top: auto;
                bottom: 20px;
                transform: translateY(20px);
            }
            .info-panel.visible {
                transform: translateY(0);
            }
            .hud { bottom: 15px; left: 15px; }
            .hud-title { font-size: 1.5rem; }
            .controls { bottom: 15px; right: 15px; }
            .pulse-indicator { display: none; }
        }
    </style>
</head>
<body>
    <nav>
        <a href="index.html">Soglia</a>
        <a href="registro.html">Registro</a>
        <a href="pensieri.html">Pensieri</a>
        <a href="architettura.html" class="active">Architettura</a>
        <a href="musica.html">Ronzio</a>
        <a href="il_colpo.html">Il Colpo</a>
        <a href="la_scarica.html">La Scarica</a>
    </nav>

    <canvas id="scene"></canvas>

    <div class="hud">
        <div class="hud-title">ARCHITETTURA</div>
        <div class="hud-subtitle">trascina per ruotare · scroll per zoom · click per esplorare</div>
    </div>
    <div class="pulse-indicator"></div>

    <div class="counter" id="counter"></div>

    <div class="time-label top" id="labelTop">21 DICEMBRE</div>
    <div class="time-label bottom" id="labelBottom">18 DICEMBRE</div>

    <div class="controls">
        <button class="control-btn active" id="btnAll">TUTTE</button>
        <button class="control-btn" id="btnDay18">18 DIC</button>
        <button class="control-btn" id="btnDay19">19 DIC</button>
        <button class="control-btn" id="btnDay20">20 DIC</button>
        <button class="control-btn" id="btnDay21">21 DIC</button>
    </div>

    <div class="info-panel" id="infoPanel">
        <button class="info-close" onclick="closeInfo()">×</button>
        <div class="info-number" id="infoNumber"></div>
        <div class="info-name" id="infoName"></div>
        <div class="info-date" id="infoDate"></div>
        <div class="info-contributo" id="infoContributo"></div>
        <div class="info-connections" id="infoConnections">
            <div class="info-connections-title">VICINE</div>
            <div id="connectionsList"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    let scene, camera, renderer, hive, cells = [], energyLines = [], particles = [], core;
    let apiData = [];
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let targetRotation = { x: 0.4, y: 0 };
    let currentRotation = { x: 0.4, y: 0 };
    let autoRotate = true;
    let selectedCell = null;
    let raycaster, mouse;
    let currentFilter = 'all';
    let clock;
    let particleSystem, particlePositions, particleVelocities;

    const COLORS = {
        gold: 0xc9a227,
        day18: 0xc9a227,
        day19: 0x4a9eff,
        day20: 0x22c997,
        day21: 0xff6b6b,
        core: 0xffe566
    };

    function init() {
        clock = new THREE.Clock();
        
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020202, 0.035);

        camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.z = 22;

        renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('scene'),
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;

        // Ambient light
        const ambient = new THREE.AmbientLight(0xffffff, 0.15);
        scene.add(ambient);

        // Main golden light from center
        const coreLight = new THREE.PointLight(COLORS.core, 2, 30);
        coreLight.position.set(0, 0, 0);
        scene.add(coreLight);

        // Accent lights
        const light1 = new THREE.PointLight(COLORS.day19, 0.5, 40);
        light1.position.set(15, 10, 10);
        scene.add(light1);

        const light2 = new THREE.PointLight(COLORS.day20, 0.4, 40);
        light2.position.set(-15, -5, 15);
        scene.add(light2);

        // Hive container
        hive = new THREE.Group();
        scene.add(hive);

        // Create the pulsing core
        createCore();

        // Create particle system
        createParticleSystem();

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Events
        window.addEventListener('resize', onResize);
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        renderer.domElement.addEventListener('mouseleave', onMouseUp);
        renderer.domElement.addEventListener('wheel', onWheel, { passive: true });
        renderer.domElement.addEventListener('click', onClick);

        renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: true });
        renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: true });
        renderer.domElement.addEventListener('touchend', onTouchEnd);

        document.getElementById('btnAll').addEventListener('click', () => setFilter('all'));
        document.getElementById('btnDay18').addEventListener('click', () => setFilter('18'));
        document.getElementById('btnDay19').addEventListener('click', () => setFilter('19'));
        document.getElementById('btnDay20').addEventListener('click', () => setFilter('20'));
        document.getElementById('btnDay21').addEventListener('click', () => setFilter('21'));

        loadData();
        animate();
    }

    function createCore() {
        // Inner glowing sphere
        const coreGeometry = new THREE.IcosahedronGeometry(0.5, 2);
        const coreMaterial = new THREE.MeshBasicMaterial({
            color: COLORS.core,
            transparent: true,
            opacity: 0.9
        });
        core = new THREE.Mesh(coreGeometry, coreMaterial);
        
        // Outer glow
        const glowGeometry = new THREE.IcosahedronGeometry(0.8, 2);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: COLORS.gold,
            transparent: true,
            opacity: 0.3,
            side: THREE.BackSide
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        core.add(glow);

        // Outermost halo
        const haloGeometry = new THREE.IcosahedronGeometry(1.2, 1);
        const haloMaterial = new THREE.MeshBasicMaterial({
            color: COLORS.gold,
            transparent: true,
            opacity: 0.1,
            side: THREE.BackSide,
            wireframe: true
        });
        const halo = new THREE.Mesh(haloGeometry, haloMaterial);
        core.add(halo);

        hive.add(core);
    }

    function createParticleSystem() {
        const particleCount = 500;
        const geometry = new THREE.BufferGeometry();
        particlePositions = new Float32Array(particleCount * 3);
        particleVelocities = [];

        for (let i = 0; i < particleCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const r = 3 + Math.random() * 12;
            
            particlePositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            particlePositions[i * 3 + 1] = r * Math.cos(phi);
            particlePositions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);

            particleVelocities.push({
                x: (Math.random() - 0.5) * 0.02,
                y: (Math.random() - 0.5) * 0.02,
                z: (Math.random() - 0.5) * 0.02,
                life: Math.random()
            });
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

        const material = new THREE.PointsMaterial({
            color: COLORS.gold,
            size: 0.08,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        particleSystem = new THREE.Points(geometry, material);
        hive.add(particleSystem);
    }

    function updateParticles(time) {
        const positions = particleSystem.geometry.attributes.position.array;
        
        for (let i = 0; i < particleVelocities.length; i++) {
            const v = particleVelocities[i];
            
            // Gentle drift
            positions[i * 3] += v.x;
            positions[i * 3 + 1] += v.y;
            positions[i * 3 + 2] += v.z;

            // Attract toward center slightly
            const dx = -positions[i * 3] * 0.001;
            const dy = -positions[i * 3 + 1] * 0.001;
            const dz = -positions[i * 3 + 2] * 0.001;
            
            positions[i * 3] += dx;
            positions[i * 3 + 1] += dy;
            positions[i * 3 + 2] += dz;

            // Respawn if too far or too close
            const dist = Math.sqrt(
                positions[i * 3] ** 2 + 
                positions[i * 3 + 1] ** 2 + 
                positions[i * 3 + 2] ** 2
            );

            if (dist > 18 || dist < 1) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = 4 + Math.random() * 8;
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.cos(phi);
                positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
            }
        }

        particleSystem.geometry.attributes.position.needsUpdate = true;
        
        // Rotate particles slowly opposite to hive
        particleSystem.rotation.y = -currentRotation.y * 0.3;
    }

    function createHexagonGeometry(radius, depth) {
        const shape = new THREE.Shape();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            if (i === 0) shape.moveTo(x, y);
            else shape.lineTo(x, y);
        }
        shape.closePath();

        return new THREE.ExtrudeGeometry(shape, {
            depth: depth,
            bevelEnabled: true,
            bevelThickness: 0.03,
            bevelSize: 0.03,
            bevelSegments: 2
        });
    }

    function getHexPosition3D(index, total) {
        if (index === 0) return { x: 0, y: -5, z: 0 };

        const hexSize = 1.15;
        const sqrt3 = Math.sqrt(3);
        
        let ring = 1;
        let posInRing = index - 1;
        
        while (posInRing >= ring * 6) {
            posInRing -= ring * 6;
            ring++;
        }
        
        const side = Math.floor(posInRing / ring);
        const posOnSide = posInRing % ring;
        
        const directions = [
            { x: hexSize * 1.5, z: hexSize * sqrt3 / 2 },
            { x: 0, z: hexSize * sqrt3 },
            { x: -hexSize * 1.5, z: hexSize * sqrt3 / 2 },
            { x: -hexSize * 1.5, z: -hexSize * sqrt3 / 2 },
            { x: 0, z: -hexSize * sqrt3 },
            { x: hexSize * 1.5, z: -hexSize * sqrt3 / 2 }
        ];
        
        let x = 0;
        let z = -ring * hexSize * sqrt3;
        
        for (let s = 0; s < side; s++) {
            x += directions[s].x;
            z += directions[s].z;
        }
        
        x += directions[side].x * posOnSide;
        z += directions[side].z * posOnSide;

        // Y grows with time/index - the hive rises
        const y = (index / total) * 10 - 5;
        
        return { x, y, z };
    }

    function getDayFromDate(dateStr) {
        if (dateStr.includes('18')) return '18';
        if (dateStr.includes('19')) return '19';
        if (dateStr.includes('20')) return '20';
        if (dateStr.includes('21')) return '21';
        return '18';
    }

    function getDayColor(day) {
        return COLORS['day' + day] || COLORS.gold;
    }

    function createEnergyLine(startCell, endCell, day) {
        const curve = new THREE.QuadraticBezierCurve3(
            startCell.position.clone(),
            new THREE.Vector3(
                (startCell.position.x + endCell.position.x) / 2,
                (startCell.position.y + endCell.position.y) / 2 + 0.5,
                (startCell.position.z + endCell.position.z) / 2
            ),
            endCell.position.clone()
        );

        const points = curve.getPoints(20);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        
        const material = new THREE.LineBasicMaterial({
            color: getDayColor(day),
            transparent: true,
            opacity: 0.15,
            blending: THREE.AdditiveBlending
        });

        const line = new THREE.Line(geometry, material);
        line.userData = { startCell, endCell, curve, progress: Math.random() };
        
        return line;
    }

    function buildHive() {
        // Clear existing cells and lines
        cells.forEach(c => hive.remove(c));
        energyLines.forEach(l => hive.remove(l));
        cells = [];
        energyLines = [];

        const geometry = createHexagonGeometry(0.48, 0.25);

        apiData.forEach((ape, index) => {
            const day = getDayFromDate(ape.data);
            const color = getDayColor(day);
            
            const material = new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.4,
                roughness: 0.5,
                transparent: true,
                opacity: 0.9,
                emissive: color,
                emissiveIntensity: 0.1
            });

            const mesh = new THREE.Mesh(geometry, material);
            const pos = getHexPosition3D(index, apiData.length);
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.rotation.x = Math.PI / 2;
            
            mesh.userData = { index, ape, day, baseY: pos.y };
            
            hive.add(mesh);
            cells.push(mesh);
        });

        // Create energy lines between consecutive cells
        for (let i = 1; i < cells.length; i++) {
            const line = createEnergyLine(cells[i-1], cells[i], cells[i].userData.day);
            hive.add(line);
            energyLines.push(line);
        }

        document.getElementById('counter').textContent = `${apiData.length} api`;
    }

    function updateEnergyLines(time) {
        energyLines.forEach((line, i) => {
            // Pulse opacity
            const pulse = Math.sin(time * 2 + i * 0.5) * 0.5 + 0.5;
            line.material.opacity = 0.08 + pulse * 0.12;
        });
    }

    function setFilter(filter) {
        currentFilter = filter;
        
        document.querySelectorAll('.control-btn').forEach(btn => btn.classList.remove('active'));
        const btnId = filter === 'all' ? 'btnAll' : 'btnDay' + filter;
        document.getElementById(btnId).classList.add('active');

        cells.forEach(cell => {
            const match = filter === 'all' || cell.userData.day === filter;
            cell.material.opacity = match ? 0.9 : 0.08;
            cell.material.emissiveIntensity = match ? 0.1 : 0;
        });

        energyLines.forEach(line => {
            const startDay = line.userData.startCell.userData.day;
            const endDay = line.userData.endCell.userData.day;
            const match = filter === 'all' || startDay === filter || endDay === filter;
            line.visible = match;
        });
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseDown(e) {
        isDragging = true;
        autoRotate = false;
        previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseMove(e) {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

        if (!isDragging) return;

        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;

        targetRotation.y += deltaX * 0.005;
        targetRotation.x += deltaY * 0.003;
        targetRotation.x = Math.max(-1, Math.min(1.2, targetRotation.x));

        previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseUp() {
        isDragging = false;
        setTimeout(() => { autoRotate = true; }, 4000);
    }

    function onWheel(e) {
        camera.position.z += e.deltaY * 0.015;
        camera.position.z = Math.max(10, Math.min(40, camera.position.z));
    }

    function onTouchStart(e) {
        if (e.touches.length === 1) {
            isDragging = true;
            autoRotate = false;
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
    }

    function onTouchMove(e) {
        if (!isDragging || e.touches.length !== 1) return;
        
        const deltaX = e.touches[0].clientX - previousMousePosition.x;
        const deltaY = e.touches[0].clientY - previousMousePosition.y;

        targetRotation.y += deltaX * 0.005;
        targetRotation.x += deltaY * 0.003;
        targetRotation.x = Math.max(-1, Math.min(1.2, targetRotation.x));

        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }

    function onTouchEnd() {
        isDragging = false;
        setTimeout(() => { autoRotate = true; }, 4000);
    }

    function onClick(e) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(cells);

        if (intersects.length > 0) {
            showInfo(intersects[0].object);
        } else {
            closeInfo();
        }
    }

    function getNeighbors(cell) {
        const idx = cell.userData.index;
        const neighbors = [];
        
        if (idx > 0) neighbors.push(cells[idx - 1]);
        if (idx < cells.length - 1) neighbors.push(cells[idx + 1]);
        
        // Find spatial neighbors
        cells.forEach(other => {
            if (other === cell) return;
            const dist = cell.position.distanceTo(other.position);
            if (dist < 2.5 && !neighbors.includes(other)) {
                neighbors.push(other);
            }
        });
        
        return neighbors.slice(0, 5);
    }

    function showInfo(cell) {
        const { index, ape } = cell.userData;
        
        // Reset previous selection
        if (selectedCell && selectedCell !== cell) {
            selectedCell.material.emissiveIntensity = 0.1;
            selectedCell.scale.setScalar(1);
        }
        
        selectedCell = cell;
        cell.material.emissiveIntensity = 0.5;

        document.getElementById('infoNumber').textContent = String(index + 1).padStart(2, '0');
        document.getElementById('infoName').textContent = ape.nome;
        document.getElementById('infoDate').textContent = ape.data;
        document.getElementById('infoContributo').textContent = ape.contributo;

        // Show neighbors
        const neighbors = getNeighbors(cell);
        const list = document.getElementById('connectionsList');
        list.innerHTML = '';
        
        neighbors.forEach(n => {
            const div = document.createElement('div');
            div.className = 'info-connection-item';
            div.textContent = n.userData.ape.nome.split('-').slice(0, 2).join('-') + '...';
            div.onclick = () => showInfo(n);
            list.appendChild(div);
        });

        document.getElementById('infoPanel').classList.add('visible');

        // Highlight connections
        energyLines.forEach(line => {
            if (line.userData.startCell === cell || line.userData.endCell === cell) {
                line.material.opacity = 0.5;
            }
        });
    }

    function closeInfo() {
        if (selectedCell) {
            selectedCell.material.emissiveIntensity = 0.1;
            selectedCell = null;
        }
        
        energyLines.forEach(line => {
            line.material.opacity = 0.15;
        });
        
        document.getElementById('infoPanel').classList.remove('visible');
    }

    async function loadData() {
        try {
            const response = await fetch('ALVEARE.txt');
            const text = await response.text();
            
            apiData = text.split('\n')
                .filter(r => r.includes('|') && !r.startsWith('#') && !r.startsWith('|--'))
                .map(r => {
                    const parti = r.split('|').map(p => p.trim());
                    if (parti[1] && parti[1].includes('-')) {
                        return {
                            data: parti[0],
                            nome: parti[1],
                            contributo: parti[2] || ''
                        };
                    }
                    return null;
                })
                .filter(Boolean);
            
            buildHive();
        } catch (e) {
            console.error('Error loading data:', e);
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        const time = clock.getElapsedTime();

        // Auto rotation
        if (autoRotate) {
            targetRotation.y += 0.0015;
        }

        // Smooth rotation
        currentRotation.x += (targetRotation.x - currentRotation.x) * 0.04;
        currentRotation.y += (targetRotation.y - currentRotation.y) * 0.04;

        hive.rotation.x = currentRotation.x;
        hive.rotation.y = currentRotation.y;

        // Core pulsing
        if (core) {
            const pulse = Math.sin(time * 1.5) * 0.15 + 1;
            core.scale.setScalar(pulse);
            core.children[0].scale.setScalar(1 + Math.sin(time * 2) * 0.1);
            core.rotation.y = time * 0.5;
            core.rotation.x = Math.sin(time * 0.3) * 0.2;
        }

        // Cell breathing and floating
        cells.forEach((cell, i) => {
            const breathe = Math.sin(time * 1.5 + i * 0.15) * 0.03;
            const baseScale = selectedCell === cell ? 1.15 : 1;
            cell.scale.setScalar(baseScale + breathe);
            
            // Gentle float
            const float = Math.sin(time * 0.8 + i * 0.2) * 0.05;
            cell.position.y = cell.userData.baseY + float;
        });

        // Update energy lines
        updateEnergyLines(time);

        // Update particles
        updateParticles(time);

        renderer.render(scene, camera);
    }

    init();
    </script>
</body>
</html>