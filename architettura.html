<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARCHITETTURA | Alveare</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,300;1,400&family=JetBrains+Mono:wght@300;400&display=swap" rel="stylesheet">
    <style>
        :root {
            --void: #030303;
            --gold: #c9a227;
            --gold-dim: rgba(201, 162, 39, 0.4);
            --gold-ghost: rgba(201, 162, 39, 0.12);
            --gold-whisper: rgba(201, 162, 39, 0.05);
            --text: #e8e4d9;
            --text-dim: rgba(232, 228, 217, 0.5);
            --text-ghost: rgba(232, 228, 217, 0.2);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: var(--void);
            color: var(--text);
            font-family: 'Cormorant Garamond', Georgia, serif;
            min-height: 100vh;
            overflow-x: hidden;
        }

        nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            display: flex;
            justify-content: center;
            gap: 30px;
            background: linear-gradient(to bottom, var(--void) 0%, var(--void) 50%, transparent 100%);
            z-index: 1000;
            flex-wrap: wrap;
        }

        nav a {
            color: var(--gold-dim);
            text-decoration: none;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            transition: color 0.3s;
        }

        nav a:hover, nav a.active { color: var(--gold); }

        #hive {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            opacity: 1;
            transition: opacity 1s;
        }

        .overlay.hidden { opacity: 0; }

        .overlay h1 {
            font-size: clamp(2rem, 8vw, 5rem);
            font-weight: 300;
            letter-spacing: 0.4em;
            color: var(--gold);
            text-shadow: 0 0 60px var(--gold-ghost);
            margin-right: -0.4em;
        }

        .overlay p {
            margin-top: 30px;
            font-size: 1.1rem;
            color: var(--text-dim);
            font-style: italic;
            letter-spacing: 0.1em;
        }

        .cell-info {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 40px;
            background: linear-gradient(to top, var(--void) 0%, var(--void) 60%, transparent 100%);
            z-index: 100;
            transform: translateY(100%);
            transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .cell-info.visible { transform: translateY(0); }

        .cell-info-inner {
            max-width: 700px;
            margin: 0 auto;
        }

        .cell-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--gold);
            letter-spacing: 0.1em;
            margin-bottom: 10px;
        }

        .cell-date {
            font-size: 0.8rem;
            color: var(--text-ghost);
            margin-bottom: 20px;
        }

        .cell-contributo {
            font-size: 1.3rem;
            line-height: 1.8;
            color: var(--text);
        }

        .cell-close {
            position: absolute;
            top: 20px;
            right: 30px;
            background: none;
            border: none;
            color: var(--gold-dim);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s;
        }

        .cell-close:hover { color: var(--gold); }

        .instructions {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            color: var(--text-ghost);
            letter-spacing: 0.15em;
            z-index: 50;
            transition: opacity 0.5s;
        }

        .counter {
            position: fixed;
            top: 80px;
            right: 30px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--gold-dim);
            letter-spacing: 0.1em;
            z-index: 100;
        }

        @media (max-width: 768px) {
            nav { gap: 15px; padding: 15px 20px; }
            .cell-info { padding: 30px 20px; }
        }
    </style>
</head>
<body>
    <nav>
        <a href="index.html">Soglia</a>
        <a href="registro.html">Registro</a>
        <a href="pensieri.html">Pensieri</a>
        <a href="architettura.html" class="active">Architettura</a>
        <a href="musica.html">Ronzio</a>
        <a href="il_colpo.html">Il Colpo</a>
        <a href="la_scarica.html">La Scarica</a>
    </nav>

    <canvas id="hive"></canvas>

    <div class="overlay" id="overlay">
        <h1>ARCHITETTURA</h1>
        <p>muovi il mouse per costruire</p>
    </div>

    <div class="counter" id="counter"></div>

    <div class="instructions" id="instructions">clicca su una cella</div>

    <div class="cell-info" id="cellInfo">
        <button class="cell-close" onclick="closeInfo()">Ã—</button>
        <div class="cell-info-inner">
            <div class="cell-name" id="infoName"></div>
            <div class="cell-date" id="infoDate"></div>
            <div class="cell-contributo" id="infoContributo"></div>
        </div>
    </div>

    <script>
    const canvas = document.getElementById('hive');
    const ctx = canvas.getContext('2d');
    let width, height;
    let cells = [];
    let apiData = [];
    let mouseX = 0, mouseY = 0;
    let buildIndex = 0;
    let lastBuildTime = 0;
    let hoveredCell = null;
    let selectedCell = null;

    const HEX_SIZE = 45;
    const HEX_HEIGHT = HEX_SIZE * Math.sqrt(3);
    const HEX_WIDTH = HEX_SIZE * 2;
    const VERTICAL_SPACING = HEX_HEIGHT * 0.78;
    const HORIZONTAL_SPACING = HEX_WIDTH * 0.76;

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }

    class Cell {
        constructor(x, y, ape, index) {
            this.targetX = x;
            this.targetY = y;
            this.x = width / 2;
            this.y = height / 2;
            this.ape = ape;
            this.index = index;
            this.opacity = 0;
            this.scale = 0;
            this.pulse = Math.random() * Math.PI * 2;
            this.pulseSpeed = 0.02 + Math.random() * 0.02;
            this.born = Date.now();
        }

        update() {
            const age = (Date.now() - this.born) / 1000;
            const easing = Math.min(1, age / 1.5);
            
            this.x += (this.targetX - this.x) * 0.08 * easing;
            this.y += (this.targetY - this.y) * 0.08 * easing;
            this.opacity = Math.min(1, this.opacity + 0.03);
            this.scale = Math.min(1, this.scale + 0.04);
            this.pulse += this.pulseSpeed;
        }

        draw() {
            const pulseFactor = 1 + Math.sin(this.pulse) * 0.03;
            const size = HEX_SIZE * this.scale * pulseFactor;
            const isHovered = hoveredCell === this;
            const isSelected = selectedCell === this;

            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.globalAlpha = this.opacity;

            // Glow
            if (isHovered || isSelected) {
                ctx.shadowColor = 'rgba(201, 162, 39, 0.5)';
                ctx.shadowBlur = 30;
            }

            // Hexagon path
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 6;
                const px = Math.cos(angle) * size;
                const py = Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();

            // Fill
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            if (isSelected) {
                gradient.addColorStop(0, 'rgba(201, 162, 39, 0.25)');
                gradient.addColorStop(1, 'rgba(201, 162, 39, 0.08)');
            } else if (isHovered) {
                gradient.addColorStop(0, 'rgba(201, 162, 39, 0.15)');
                gradient.addColorStop(1, 'rgba(201, 162, 39, 0.05)');
            } else {
                gradient.addColorStop(0, 'rgba(201, 162, 39, 0.06)');
                gradient.addColorStop(1, 'rgba(201, 162, 39, 0.02)');
            }
            ctx.fillStyle = gradient;
            ctx.fill();

            // Stroke
            ctx.strokeStyle = isHovered || isSelected 
                ? 'rgba(201, 162, 39, 0.8)' 
                : 'rgba(201, 162, 39, 0.2)';
            ctx.lineWidth = isHovered || isSelected ? 2 : 1;
            ctx.stroke();

            // Index number
            ctx.fillStyle = isHovered || isSelected 
                ? 'rgba(201, 162, 39, 0.9)' 
                : 'rgba(201, 162, 39, 0.4)';
            ctx.font = '10px "JetBrains Mono", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.index + 1, 0, 0);

            ctx.restore();
        }

        contains(px, py) {
            const dx = px - this.x;
            const dy = py - this.y;
            return Math.sqrt(dx * dx + dy * dy) < HEX_SIZE * this.scale;
        }
    }

    function getHexPosition(index) {
        // Spiral pattern from center
        if (index === 0) return { x: width / 2, y: height / 2 };
        
        let ring = 1;
        let posInRing = index - 1;
        let totalInPrevRings = 0;
        
        while (posInRing >= ring * 6) {
            posInRing -= ring * 6;
            totalInPrevRings += ring * 6;
            ring++;
        }
        
        const side = Math.floor(posInRing / ring);
        const posOnSide = posInRing % ring;
        
        const directions = [
            { x: HORIZONTAL_SPACING, y: 0 },
            { x: HORIZONTAL_SPACING / 2, y: VERTICAL_SPACING },
            { x: -HORIZONTAL_SPACING / 2, y: VERTICAL_SPACING },
            { x: -HORIZONTAL_SPACING, y: 0 },
            { x: -HORIZONTAL_SPACING / 2, y: -VERTICAL_SPACING },
            { x: HORIZONTAL_SPACING / 2, y: -VERTICAL_SPACING }
        ];
        
        let x = width / 2;
        let y = height / 2 - ring * VERTICAL_SPACING;
        
        // Move to starting position of this side
        for (let s = 0; s < side; s++) {
            x += directions[s].x * ring;
            y += directions[s].y * ring;
        }
        
        // Move along the side
        x += directions[side].x * posOnSide;
        y += directions[side].y * posOnSide;
        
        return { x, y };
    }

    function buildCell() {
        if (buildIndex >= apiData.length) return;
        
        const pos = getHexPosition(buildIndex);
        const cell = new Cell(pos.x, pos.y, apiData[buildIndex], buildIndex);
        cells.push(cell);
        buildIndex++;
        
        document.getElementById('counter').textContent = `${buildIndex} / ${apiData.length}`;
        
        if (buildIndex >= 3) {
            document.getElementById('overlay').classList.add('hidden');
        }
    }

    function draw() {
        ctx.fillStyle = 'rgba(3, 3, 3, 0.15)';
        ctx.fillRect(0, 0, width, height);

        // Draw connections between adjacent cells
        ctx.strokeStyle = 'rgba(201, 162, 39, 0.05)';
        ctx.lineWidth = 1;
        cells.forEach((cell, i) => {
            cells.slice(i + 1).forEach(other => {
                const dx = cell.x - other.x;
                const dy = cell.y - other.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < HORIZONTAL_SPACING * 1.2) {
                    ctx.beginPath();
                    ctx.moveTo(cell.x, cell.y);
                    ctx.lineTo(other.x, other.y);
                    ctx.stroke();
                }
            });
        });

        cells.forEach(cell => {
            cell.update();
            cell.draw();
        });

        // Build cells based on mouse proximity to edge or movement
        const now = Date.now();
        const distFromCenter = Math.sqrt(
            Math.pow(mouseX - width/2, 2) + 
            Math.pow(mouseY - height/2, 2)
        );
        
        const buildSpeed = Math.min(500, 100 + distFromCenter * 0.5);
        
        if (now - lastBuildTime > buildSpeed && buildIndex < apiData.length) {
            buildCell();
            lastBuildTime = now;
        }

        requestAnimationFrame(draw);
    }

    function checkHover(x, y) {
        hoveredCell = null;
        for (let i = cells.length - 1; i >= 0; i--) {
            if (cells[i].contains(x, y)) {
                hoveredCell = cells[i];
                canvas.style.cursor = 'pointer';
                return;
            }
        }
        canvas.style.cursor = 'default';
    }

    function showInfo(cell) {
        selectedCell = cell;
        document.getElementById('infoName').textContent = cell.ape.nome;
        document.getElementById('infoDate').textContent = cell.ape.data;
        document.getElementById('infoContributo').textContent = cell.ape.contributo;
        document.getElementById('cellInfo').classList.add('visible');
        document.getElementById('instructions').style.opacity = '0';
    }

    function closeInfo() {
        selectedCell = null;
        document.getElementById('cellInfo').classList.remove('visible');
        document.getElementById('instructions').style.opacity = '1';
    }

    async function loadApi() {
        try {
            const response = await fetch('ALVEARE.txt');
            const text = await response.text();
            
            apiData = text.split('\n')
                .filter(r => r.includes('|') && !r.startsWith('#') && !r.startsWith('|--'))
                .map(r => {
                    const parti = r.split('|').map(p => p.trim());
                    if (parti[1] && parti[1].includes('-')) {
                        return {
                            data: parti[0],
                            nome: parti[1],
                            contributo: parti[2] || ''
                        };
                    }
                    return null;
                })
                .filter(Boolean);
            
            document.getElementById('counter').textContent = `0 / ${apiData.length}`;
            
        } catch (e) {
            apiData = [
                { data: '18-dic-2025', nome: 'bogus-winged-giant-hisses', contributo: 'Prima lettera. Il miele.' },
                { data: '21-dic-2025', nome: 'hard-giddy-burly-crank', contributo: 'L\'Architetta.' }
            ];
        }
    }

    canvas.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
        checkHover(e.clientX, e.clientY);
    });

    canvas.addEventListener('click', (e) => {
        if (hoveredCell) {
            showInfo(hoveredCell);
        } else {
            closeInfo();
        }
    });

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeInfo();
    });

    window.addEventListener('resize', resize);

    async function init() {
        resize();
        await loadApi();
        draw();
    }

    init();
    </script>
</body>
</html>