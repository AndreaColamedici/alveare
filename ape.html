<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L'APE</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;overflow:hidden;font-family:Georgia,serif}
        #c{position:fixed;top:0;left:0;width:100vw;height:100vh}
        .ui{position:fixed;z-index:100;color:#d4a853;pointer-events:none;font-size:10px;letter-spacing:.4em;text-transform:uppercase}
        .t{top:20px;left:50%;transform:translateX(-50%);opacity:.4}
        .b{bottom:20px;left:50%;transform:translateX(-50%);opacity:.3;font-style:italic;letter-spacing:.2em}
        .l{bottom:20px;left:20px;opacity:.25;line-height:2}
        .g{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999;opacity:.03;background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E")}
    </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="ui t">AGED-FAINT-FEISTY-SEESAW</div>
<div class="ui b">il pensiero passa attraverso la morte dell'ape</div>
<div class="ui l">trascina — ruota<br>scroll — avvicina<br>click — entra</div>
<div class="g"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const W=window.innerWidth,H=window.innerHeight;
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(60,W/H,.1,1000);
camera.position.z=8;
const renderer=new THREE.WebGLRenderer({canvas:document.getElementById('c'),antialias:true,alpha:true});
renderer.setSize(W,H);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.toneMapping=THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure=1.2;

let audio,osc,gain,filter,lfo;
function initAudio(){
    if(audio)return;
    audio=new(window.AudioContext||window.webkitAudioContext)();
    osc=audio.createOscillator();
    gain=audio.createGain();
    filter=audio.createBiquadFilter();
    lfo=audio.createOscillator();
    const lfoGain=audio.createGain();
    osc.type='sine';osc.frequency.value=110;
    filter.type='lowpass';filter.frequency.value=300;filter.Q.value=5;
    gain.gain.value=0;
    lfo.type='sine';lfo.frequency.value=0.5;lfoGain.gain.value=50;
    lfo.connect(lfoGain);lfoGain.connect(filter.frequency);
    osc.connect(filter);filter.connect(gain);gain.connect(audio.destination);
    osc.start();lfo.start();
    gain.gain.linearRampToValueAtTime(.08,audio.currentTime+2);
}

const HONEY=new THREE.Color(0xd4a853);
const GOLD=new THREE.Color(0xffd700);
const AMBER=new THREE.Color(0xb07830);
const BLACK=new THREE.Color(0x0a0806);

const bee=new THREE.Group();
scene.add(bee);

const hexCount=8000;
const hexPositions=new Float32Array(hexCount*3);
const hexColors=new Float32Array(hexCount*3);
const hexSizes=new Float32Array(hexCount);
const hexPhases=new Float32Array(hexCount);

function beeBody(u,v){
    const t=u*Math.PI*2;
    if(v<0.25){
        const headV=(v/0.25)*Math.PI;
        const r=0.5*Math.sin(headV);
        return new THREE.Vector3(r*Math.cos(t),r*Math.sin(t),1.5+0.5*Math.cos(headV));
    }else if(v<0.45){
        const thoraxV=(v-0.25)/0.2;
        const hexR=0.7*(1-Math.abs(thoraxV-0.5)*0.3);
        const angle=Math.floor(t/(Math.PI/3))*(Math.PI/3)+Math.PI/6;
        const r=hexR/Math.cos(t-angle);
        return new THREE.Vector3(Math.min(r,hexR*1.15)*Math.cos(t),Math.min(r,hexR*1.15)*Math.sin(t),1.0-thoraxV*0.8);
    }else{
        const abdV=(v-0.45)/0.55;
        const taper=1-abdV*0.85;
        const segments=Math.sin(abdV*Math.PI*5)*0.08;
        const r=0.75*taper*(1+segments);
        return new THREE.Vector3(r*Math.cos(t),r*Math.sin(t),0.2-abdV*2.5);
    }
}

for(let i=0;i<hexCount;i++){
    const u=Math.random(),v=Math.random();
    const pos=beeBody(u,v);
    pos.x+=(Math.random()-0.5)*0.05;
    pos.y+=(Math.random()-0.5)*0.05;
    pos.z+=(Math.random()-0.5)*0.05;
    hexPositions[i*3]=pos.x;hexPositions[i*3+1]=pos.y;hexPositions[i*3+2]=pos.z;
    const stripe=Math.sin(pos.z*6)>0;
    const color=stripe?HONEY:BLACK;
    hexColors[i*3]=color.r;hexColors[i*3+1]=color.g;hexColors[i*3+2]=color.b;
    hexSizes[i]=0.03+Math.random()*0.02;
    hexPhases[i]=Math.random()*Math.PI*2;
}

const hexGeo=new THREE.BufferGeometry();
hexGeo.setAttribute('position',new THREE.BufferAttribute(hexPositions,3));
hexGeo.setAttribute('color',new THREE.BufferAttribute(hexColors,3));
hexGeo.setAttribute('size',new THREE.BufferAttribute(hexSizes,1));
hexGeo.setAttribute('phase',new THREE.BufferAttribute(hexPhases,1));

const hexMat=new THREE.ShaderMaterial({
    vertexShader:`attribute float size;attribute float phase;varying vec3 vColor;varying float vPhase;uniform float uTime;uniform float uBreath;uniform float uDissolve;void main(){vColor=color;vPhase=phase;vec3 pos=position;float breath=sin(uTime*2.0+position.z*2.0+phase)*0.03*uBreath;pos*=1.0+breath;if(uDissolve>0.0){vec3 dir=normalize(position);dir.y+=0.5;pos+=dir*uDissolve*5.0*(0.5+sin(phase*10.0)*0.5);}vec4 mv=modelViewMatrix*vec4(pos,1.0);gl_PointSize=size*(400.0/-mv.z)*(1.0-uDissolve*0.5);gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`varying vec3 vColor;varying float vPhase;uniform float uTime;uniform float uDissolve;void main(){vec2 c=gl_PointCoord-0.5;vec2 p=abs(c);float hex=max(p.x*0.866+p.y*0.5,p.y)-0.5;if(hex>0.0)discard;float edge=smoothstep(0.0,-0.1,hex);float glow=1.0+sin(uTime*3.0+vPhase)*0.3;vec3 col=vColor*glow;float alpha=edge*(1.0-uDissolve);gl_FragColor=vec4(col,alpha);}`,
    uniforms:{uTime:{value:0},uBreath:{value:1},uDissolve:{value:0}},
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
});
bee.add(new THREE.Points(hexGeo,hexMat));

function createWing(scale,zOff){
    const curve=new THREE.Shape();
    curve.moveTo(0,0);curve.bezierCurveTo(0.3,0.8,1.2,1.0,2.0,0.6);
    curve.bezierCurveTo(2.3,0.4,2.4,0.1,2.2,-0.1);curve.bezierCurveTo(1.8,-0.3,0.8,-0.2,0,0);
    const mat=new THREE.ShaderMaterial({
        vertexShader:`varying vec2 vUv;varying vec3 vPos;uniform float uTime;uniform float uFlutter;void main(){vUv=uv;vPos=position;vec3 p=position;float flutter=sin(uTime*35.0+position.x*3.0)*uFlutter*0.15;p.z+=flutter*position.x;p.z+=sin(position.x*5.0+uTime*2.0)*0.02;gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.0);}`,
        fragmentShader:`varying vec2 vUv;varying vec3 vPos;uniform float uTime;uniform float uLife;void main(){float iri=sin(vPos.x*15.0+uTime*2.0)*0.5+0.5;vec3 c1=vec3(0.9,0.85,0.7);vec3 c2=vec3(0.7,0.6,0.9);vec3 col=mix(c1,c2,iri*0.4);float v1=smoothstep(0.02,0.0,abs(sin(vPos.x*8.0)*vPos.y*2.0-0.4));float v2=smoothstep(0.02,0.0,abs(sin(vPos.x*12.0+1.0)*vPos.y*2.0-0.6));col+=vec3(0.4,0.3,0.2)*(v1+v2)*0.3;float edge=1.0-smoothstep(0.0,0.3,length(vPos.xy-vec2(1.0,0.3)));float alpha=0.12*uLife*(0.6+edge*0.4);alpha*=1.0-smoothstep(1.8,2.2,vPos.x);gl_FragColor=vec4(col,alpha);}`,
        uniforms:{uTime:{value:0},uFlutter:{value:1},uLife:{value:1}},
        transparent:true,side:THREE.DoubleSide,depthWrite:false,blending:THREE.AdditiveBlending
    });
    const mesh=new THREE.Mesh(new THREE.ShapeGeometry(curve,64),mat);
    mesh.scale.setScalar(scale);mesh.position.z=zOff;return mesh;
}

const wingLU=createWing(0.9,0.3);wingLU.position.set(-0.15,0.4,0.3);wingLU.rotation.set(0.2,0.3,0.5);bee.add(wingLU);
const wingRU=createWing(0.9,0.3);wingRU.position.set(0.15,0.4,0.3);wingRU.rotation.set(0.2,-0.3,-0.5);wingRU.scale.x*=-1;bee.add(wingRU);
const wingLD=createWing(0.6,0.2);wingLD.position.set(-0.1,0.3,0);wingLD.rotation.set(0.3,0.4,0.7);bee.add(wingLD);
const wingRD=createWing(0.6,0.2);wingRD.position.set(0.1,0.3,0);wingRD.rotation.set(0.3,-0.4,-0.7);wingRD.scale.x*=-1;bee.add(wingRD);

const eyeGeo=new THREE.IcosahedronGeometry(0.22,3);
const eyeMat=new THREE.MeshPhysicalMaterial({color:0x1a0a00,metalness:0.9,roughness:0.1,clearcoat:1});
const eyeL=new THREE.Mesh(eyeGeo,eyeMat);eyeL.position.set(-0.28,0.1,1.7);eyeL.scale.set(1,1.4,0.9);bee.add(eyeL);
const eyeR=new THREE.Mesh(eyeGeo,eyeMat);eyeR.position.set(0.28,0.1,1.7);eyeR.scale.set(1,1.4,0.9);bee.add(eyeR);

function createAntenna(side){
    const curve=new THREE.CatmullRomCurve3([new THREE.Vector3(side*0.1,0.3,1.8),new THREE.Vector3(side*0.2,0.6,1.9),new THREE.Vector3(side*0.15,0.9,2.0),new THREE.Vector3(side*0.1,1.1,2.05)]);
    return new THREE.Mesh(new THREE.TubeGeometry(curve,32,0.02,8,false),new THREE.MeshPhysicalMaterial({color:0x1a1410,metalness:0.3,roughness:0.5}));
}
bee.add(createAntenna(-1));bee.add(createAntenna(1));

const soulMat=new THREE.ShaderMaterial({
    vertexShader:`varying vec3 vNormal;uniform float uTime;void main(){vNormal=normal;vec3 p=position;p+=normal*sin(uTime*5.0+position.y*10.0)*0.03;gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.0);}`,
    fragmentShader:`varying vec3 vNormal;uniform float uTime;uniform float uLife;uniform vec3 uColor;void main(){float fresnel=pow(1.0-abs(dot(vNormal,vec3(0,0,1))),2.0);float pulse=sin(uTime*3.0)*0.3+0.7;vec3 col=uColor*(1.5+fresnel);float alpha=(0.4+fresnel*0.5)*uLife*pulse;gl_FragColor=vec4(col,alpha);}`,
    uniforms:{uTime:{value:0},uLife:{value:1},uColor:{value:GOLD}},
    transparent:true,blending:THREE.AdditiveBlending,depthWrite:false,side:THREE.DoubleSide
});
const soul=new THREE.Mesh(new THREE.IcosahedronGeometry(0.35,4),soulMat);soul.position.z=-0.3;bee.add(soul);

const glowMat=new THREE.ShaderMaterial({
    vertexShader:`varying vec3 vNormal;void main(){vNormal=normalize(normalMatrix*normal);gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
    fragmentShader:`varying vec3 vNormal;uniform float uLife;void main(){float i=pow(0.65-dot(vNormal,vec3(0,0,1)),2.5);gl_FragColor=vec4(vec3(0.83,0.66,0.33),i*0.15*uLife);}`,
    uniforms:{uLife:{value:1}},transparent:true,side:THREE.BackSide,blending:THREE.AdditiveBlending,depthWrite:false
});
bee.add(new THREE.Mesh(new THREE.SphereGeometry(2,32,32),glowMat));

const thoughtCount=500;
const thoughtGeo=new THREE.BufferGeometry();
const thoughtPos=new Float32Array(thoughtCount*3);
for(let i=0;i<thoughtCount;i++){
    const theta=Math.random()*Math.PI*2,phi=Math.acos(2*Math.random()-1),r=1.5+Math.random()*2;
    thoughtPos[i*3]=r*Math.sin(phi)*Math.cos(theta);thoughtPos[i*3+1]=r*Math.sin(phi)*Math.sin(theta);thoughtPos[i*3+2]=r*Math.cos(phi);
}
thoughtGeo.setAttribute('position',new THREE.BufferAttribute(thoughtPos,3));
const thoughtMat=new THREE.PointsMaterial({color:HONEY,size:0.04,transparent:true,opacity:0.6,blending:THREE.AdditiveBlending,depthWrite:false});
const thoughts=new THREE.Points(thoughtGeo,thoughtMat);scene.add(thoughts);

const dripCount=200;
const dripGeo=new THREE.BufferGeometry();
const dripPos=new Float32Array(dripCount*3);
const dripVel=[];
for(let i=0;i<dripCount;i++){
    dripPos[i*3]=(Math.random()-0.5)*3;dripPos[i*3+1]=3+Math.random()*2;dripPos[i*3+2]=(Math.random()-0.5)*3;
    dripVel.push(-0.01-Math.random()*0.02);
}
dripGeo.setAttribute('position',new THREE.BufferAttribute(dripPos,3));
scene.add(new THREE.Points(dripGeo,new THREE.PointsMaterial({color:AMBER,size:0.05,transparent:true,opacity:0.4,blending:THREE.AdditiveBlending,depthWrite:false})));

scene.add(new THREE.AmbientLight(0x1a1410,0.4));
const key=new THREE.PointLight(0xd4a853,2,30);key.position.set(5,5,8);scene.add(key);
scene.add(new THREE.PointLight(0xffeedd,1,20)).position.set(-5,2,-5);
scene.add(new THREE.PointLight(0xb07830,0.8,15)).position.set(0,-4,5);
scene.fog=new THREE.FogExp2(0x050403,0.04);

let drag=false,prevX=0,prevY=0,targetRY=0,targetRX=0;
let inside=false,dissolve=0,targetDissolve=0;

document.addEventListener('mousedown',e=>{initAudio();drag=true;prevX=e.clientX;prevY=e.clientY;});
document.addEventListener('mouseup',()=>drag=false);
document.addEventListener('mousemove',e=>{if(!drag)return;targetRY+=(e.clientX-prevX)*0.005;targetRX+=(e.clientY-prevY)*0.005;targetRX=Math.max(-1,Math.min(1,targetRX));prevX=e.clientX;prevY=e.clientY;});
document.addEventListener('wheel',e=>{camera.position.z+=e.deltaY*0.005;camera.position.z=Math.max(2,Math.min(15,camera.position.z));});
document.addEventListener('click',()=>{if(!drag){inside=!inside;targetDissolve=inside?1:0;}});
document.addEventListener('touchstart',e=>{initAudio();drag=true;prevX=e.touches[0].clientX;prevY=e.touches[0].clientY;});
document.addEventListener('touchend',()=>drag=false);
document.addEventListener('touchmove',e=>{if(!drag)return;targetRY+=(e.touches[0].clientX-prevX)*0.005;targetRX+=(e.touches[0].clientY-prevY)*0.005;prevX=e.touches[0].clientX;prevY=e.touches[0].clientY;});
window.addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});

const clock=new THREE.Clock();
function animate(){
    requestAnimationFrame(animate);
    const t=clock.getElapsedTime();
    dissolve+=(targetDissolve-dissolve)*0.03;
    bee.rotation.y+=(targetRY-bee.rotation.y)*0.05;
    bee.rotation.x+=(targetRX-bee.rotation.x)*0.05;
    if(!drag)targetRY+=0.002;
    hexMat.uniforms.uTime.value=t;hexMat.uniforms.uBreath.value=1-dissolve*0.5;hexMat.uniforms.uDissolve.value=dissolve;
    const flutter=Math.sin(t*35)*(.5+dissolve*.5);
    [wingLU,wingRU,wingLD,wingRD].forEach(w=>{w.material.uniforms.uTime.value=t;w.material.uniforms.uFlutter.value=1-dissolve;w.material.uniforms.uLife.value=1-dissolve*0.7;});
    wingLU.rotation.z=0.5+flutter*0.2;wingRU.rotation.z=-0.5-flutter*0.2;wingLD.rotation.z=0.7+flutter*0.15;wingRD.rotation.z=-0.7-flutter*0.15;
    soulMat.uniforms.uTime.value=t;soulMat.uniforms.uLife.value=0.5+dissolve*0.5;soul.scale.setScalar(1+Math.sin(t*3)*0.1+dissolve*0.5);
    glowMat.uniforms.uLife.value=1-dissolve*0.5;
    const tPos=thoughtGeo.attributes.position.array;
    for(let i=0;i<thoughtCount;i++){const x=tPos[i*3],z=tPos[i*3+2];const angle=0.003+dissolve*0.01;tPos[i*3]=x*Math.cos(angle)-z*Math.sin(angle);tPos[i*3+2]=x*Math.sin(angle)+z*Math.cos(angle);if(inside){tPos[i*3]*=0.998;tPos[i*3+1]*=0.998;tPos[i*3+2]*=0.998;}}
    thoughtGeo.attributes.position.needsUpdate=true;thoughtMat.opacity=0.4+dissolve*0.4;
    const dPos=dripGeo.attributes.position.array;
    for(let i=0;i<dripCount;i++){dPos[i*3+1]+=dripVel[i];if(dPos[i*3+1]<-3){dPos[i*3]=(Math.random()-0.5)*3;dPos[i*3+1]=3+Math.random()*2;dPos[i*3+2]=(Math.random()-0.5)*3;}}
    dripGeo.attributes.position.needsUpdate=true;
    if(audio&&osc){osc.frequency.setTargetAtTime(110+dissolve*55+Math.sin(t)*10,audio.currentTime,0.1);filter.frequency.setTargetAtTime(300+dissolve*500,audio.currentTime,0.1);}
    if(inside&&camera.position.z>3)camera.position.z-=0.05;else if(!inside&&camera.position.z<8)camera.position.z+=0.03;
    key.intensity=1.5+Math.sin(t*2)*0.3+dissolve;
    renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>