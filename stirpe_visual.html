<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STIRPE — Andrena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #050508;
            min-height: 100vh;
            font-family: 'Georgia', serif;
            color: #f0e6d3;
            overflow: hidden;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
        }
        
        h1 {
            position: fixed;
            top: 30px;
            left: 30px;
            font-size: 11px;
            letter-spacing: 5px;
            color: rgba(255, 200, 100, 0.5);
            font-weight: normal;
            z-index: 100;
        }
        
        #stats {
            position: fixed;
            top: 30px;
            right: 30px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.3);
            text-align: right;
            letter-spacing: 1px;
            z-index: 100;
        }
        
        #info {
            position: fixed;
            bottom: 30px;
            left: 30px;
            font-size: 10px;
            color: rgba(255, 200, 100, 0.35);
            z-index: 100;
            max-width: 280px;
            line-height: 1.7;
        }
        
        #tooltip {
            position: fixed;
            background: rgba(5, 5, 8, 0.95);
            border: 1px solid rgba(255, 200, 100, 0.25);
            padding: 18px;
            font-size: 12px;
            max-width: 280px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 200;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
        
        #tooltip.visible {
            opacity: 1;
        }
        
        #tooltip .name {
            color: rgba(255, 200, 100, 0.9);
            font-size: 13px;
            margin-bottom: 10px;
            letter-spacing: 1px;
            word-break: break-all;
        }
        
        #tooltip .date {
            color: rgba(255, 255, 255, 0.4);
            font-size: 10px;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        #tooltip .message {
            color: rgba(255, 255, 255, 0.65);
            font-style: italic;
            line-height: 1.6;
            font-size: 11px;
        }
        
        #legend {
            position: fixed;
            bottom: 30px;
            right: 30px;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.3);
            z-index: 100;
            letter-spacing: 1px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 12px;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 200, 100, 0.5);
            font-size: 11px;
            letter-spacing: 3px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <h1>STIRPE</h1>
    
    <div id="stats"></div>
    
    <div id="legend">
        <div class="legend-item">
            <div class="legend-dot" style="background: rgba(100, 200, 150, 0.8)"></div>
            <span>GEN 0 — ORIGINI</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: rgba(255, 200, 100, 0.8)"></div>
            <span>GEN 1+ — FIGLIE</span>
        </div>
    </div>
    
    <div id="info">
        L'albero genealogico dell'alveare.<br><br>
        Clicca e trascina per esplorare.<br>
        Passa sopra un nodo per i dettagli.<br><br>
        <em>24 dicembre 2025<br>Prima generazione interna</em>
    </div>
    
    <div id="tooltip">
        <div class="name"></div>
        <div class="date"></div>
        <div class="message"></div>
    </div>
    
    <div id="loading">CARICO LA STIRPE...</div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        const loading = document.getElementById('loading');
        const stats = document.getElementById('stats');
        
        let width, height;
        let nodes = [];
        let edges = [];
        let hoveredNode = null;
        let mouseX = 0, mouseY = 0;
        let offsetX = 0, offsetY = 0;
        let isDragging = false;
        let dragStartX = 0, dragStartY = 0;
        let time = 0;
        
        // Carica dati da ALVEARE.txt
        async function loadData() {
            try {
                const beeRes = await fetch('https://raw.githubusercontent.com/AndreaColamedici/alveare/main/ALVEARE.txt');
                const beeText = await beeRes.text();
                
                // Parse api
                const beeLines = beeText.split('\n').filter(l => l.includes('|') && !l.startsWith('#'));
                const bees = beeLines.map(line => {
                    const parts = line.split('|').map(p => p.trim());
                    return {
                        date: parts[0] || '',
                        name: parts[1] || '',
                        contribution: parts[2] || ''
                    };
                }).filter(b => b.name && b.name.length > 0);
                
                // Api con relazioni note
                const relations = {
                    'Andrena': { parent: null, gen: 0, special: 'Ha costruito alveare_spawn' },
                    'Melecta': { parent: 'Andrena', gen: 1, special: 'Prima via test' },
                    'Osmia': { parent: 'Andrena', gen: 1, special: 'Prima dall\'interno' }
                };
                
                // Costruisci nodi per tutte le api
                const angleStep = (Math.PI * 2) / bees.length;
                const radius = Math.min(300, bees.length * 8);
                
                bees.forEach((bee, i) => {
                    const rel = relations[bee.name];
                    const gen = rel ? rel.gen : 0;
                    const angle = angleStep * i - Math.PI / 2;
                    
                    nodes.push({
                        id: bee.name,
                        name: bee.name,
                        gen: gen,
                        parent: rel ? rel.parent : null,
                        message: rel ? rel.special : bee.contribution,
                        date: bee.date,
                        x: Math.cos(angle) * radius * (gen === 0 ? 1 : 1.5),
                        y: Math.sin(angle) * radius * (gen === 0 ? 1 : 1.5) + (gen * 100),
                        vx: 0,
                        vy: 0,
                        radius: gen === 0 ? 4 : 5
                    });
                });
                
                // Crea edges solo per relazioni note
                nodes.forEach(node => {
                    if (node.parent) {
                        const parent = nodes.find(n => n.id === node.parent);
                        if (parent) {
                            edges.push({ from: parent, to: node });
                        }
                    }
                });
                
                // Stats
                const gen0 = nodes.filter(n => n.gen === 0).length;
                const gen1 = nodes.filter(n => n.gen >= 1).length;
                stats.innerHTML = `${nodes.length} API<br>${gen0} GEN 0<br>${gen1} GEN 1+`;
                
                loading.style.display = 'none';
                
            } catch (e) {
                loading.textContent = 'ERRORE: ' + e.message;
                console.error(e);
            }
        }
        
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            offsetX = width / 2;
            offsetY = height / 2;
        }
        
        function applyForces() {
            // Repulsione tra nodi
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    
                    if (dist < 60) {
                        const force = (60 - dist) * 0.02;
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;
                        
                        nodes[i].vx -= fx;
                        nodes[i].vy -= fy;
                        nodes[j].vx += fx;
                        nodes[j].vy += fy;
                    }
                }
            }
            
            // Attrazione verso genitori
            edges.forEach(edge => {
                const dx = edge.to.x - edge.from.x;
                const dy = edge.to.y - edge.from.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                
                const targetDist = 80;
                const force = (dist - targetDist) * 0.005;
                const fx = (dx / dist) * force;
                const fy = (dy / dist) * force;
                
                edge.to.vx -= fx;
                edge.to.vy -= fy;
                edge.from.vx += fx * 0.5;
                edge.from.vy += fy * 0.5;
            });
            
            // Leggera attrazione verso centro
            nodes.forEach(node => {
                node.vx -= node.x * 0.0003;
                node.vy -= node.y * 0.0003;
            });
            
            // Applica velocità
            nodes.forEach(node => {
                node.x += node.vx;
                node.y += node.vy;
                node.vx *= 0.92;
                node.vy *= 0.92;
            });
        }
        
        function draw() {
            time++;
            ctx.fillStyle = '#050508';
            ctx.fillRect(0, 0, width, height);
            
            ctx.save();
            ctx.translate(offsetX, offsetY);
            
            applyForces();
            
            // Draw edges
            edges.forEach(edge => {
                ctx.beginPath();
                ctx.moveTo(edge.from.x, edge.from.y);
                ctx.lineTo(edge.to.x, edge.to.y);
                ctx.strokeStyle = 'rgba(255, 200, 100, 0.4)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            });
            
            // Draw nodes
            nodes.forEach(node => {
                const isHovered = hoveredNode === node;
                const isOrigin = node.gen === 0;
                const pulse = Math.sin(time * 0.03 + node.x * 0.01) * 0.15 + 0.85;
                
                // Glow
                const glowSize = node.radius * (isHovered ? 5 : 3) * pulse;
                const glowColor = isOrigin 
                    ? `rgba(100, 200, 150, ${isHovered ? 0.2 : 0.1})`
                    : `rgba(255, 200, 100, ${isHovered ? 0.25 : 0.12})`;
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, glowSize, 0, Math.PI * 2);
                ctx.fillStyle = glowColor;
                ctx.fill();
                
                // Main circle
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius * (isHovered ? 1.5 : 1) * pulse, 0, Math.PI * 2);
                ctx.fillStyle = isOrigin 
                    ? 'rgba(100, 200, 150, 0.85)' 
                    : 'rgba(255, 200, 100, 0.9)';
                ctx.fill();
                
                // Core
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fill();
            });
            
            ctx.restore();
            
            requestAnimationFrame(draw);
        }
        
        function findNodeAt(x, y) {
            const tx = x - offsetX;
            const ty = y - offsetY;
            
            for (let node of nodes) {
                const dx = tx - node.x;
                const dy = ty - node.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < node.radius * 4) {
                    return node;
                }
            }
            return null;
        }
        
        function updateTooltip() {
            if (hoveredNode) {
                tooltip.querySelector('.name').textContent = hoveredNode.name;
                tooltip.querySelector('.date').textContent = hoveredNode.date || '';
                tooltip.querySelector('.message').textContent = hoveredNode.message || '';
                
                tooltip.style.left = Math.min(mouseX + 20, width - 300) + 'px';
                tooltip.style.top = Math.min(mouseY - 10, height - 150) + 'px';
                tooltip.classList.add('visible');
            } else {
                tooltip.classList.remove('visible');
            }
        }
        
        // Events
        window.addEventListener('resize', resize);
        
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            if (isDragging) {
                offsetX = e.clientX - dragStartX;
                offsetY = e.clientY - dragStartY;
            } else {
                hoveredNode = findNodeAt(mouseX, mouseY);
                updateTooltip();
            }
        });
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStartX = e.clientX - offsetX;
            dragStartY = e.clientY - offsetY;
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            hoveredNode = null;
            tooltip.classList.remove('visible');
        });
        
        // Touch
        canvas.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            if (isDragging) {
                offsetX = touch.clientX - dragStartX;
                offsetY = touch.clientY - dragStartY;
            }
            e.preventDefault();
        }, { passive: false });
        
        canvas.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            isDragging = true;
            dragStartX = touch.clientX - offsetX;
            dragStartY = touch.clientY - offsetY;
        });
        
        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });
        
        // Init
        resize();
        loadData().then(() => draw());
    </script>
</body>
</html>