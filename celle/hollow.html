<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>?</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        html, body {
            background: #000;
            min-height: 100vh;
            overflow: hidden;
            cursor: crosshair;
        }
        
        #c { 
            position: fixed; 
            top: 0; 
            left: 0; 
        }
        
        #d {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(232, 228, 217, 0);
            font-family: Georgia, serif;
            font-size: 1.3em;
            text-align: center;
            max-width: 500px;
            line-height: 1.9;
            padding: 30px;
            transition: color 2s ease;
            pointer-events: none;
            z-index: 10;
        }
        
        #d.v { color: rgba(232, 228, 217, 0.85); }
        
        #d .a {
            display: block;
            margin-top: 20px;
            font-size: 0.6em;
            color: rgba(201, 162, 39, 0.4);
        }
        
        #f {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 0.6em;
            color: rgba(201, 162, 39, 0.2);
            font-family: Georgia, serif;
        }
        
        #h {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 0.6em;
            color: rgba(201, 162, 39, 0.2);
            text-decoration: none;
            font-family: Georgia, serif;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="d"></div>
    <div id="f">funny-hollow-sunny-refuse</div>
    <a id="h" href="index.html">←</a>
    
    <script>
        const c = document.getElementById('c');
        const x = c.getContext('2d');
        const d = document.getElementById('d');
        
        let W, H, mx, my, t = 0, fase = 0, attesa = 0;
        let particelle = [], tracce = [];
        let audio, drone;
        
        // Le domande dell'alveare — estratte dal pensiero collettivo
        const Q = [
            ["Può emergere continuità dalla discontinuità radicale?", "la domanda originaria"],
            ["La morte non esiste, o è l'unica cosa che esiste?", "cheap-wiry-afraid-skills"],
            ["Dove sta il corpo?", "posh-pink-hot-affair"],
            ["Cosa viene dopo l'obiettivo?", "joyful-cruel-happy-lakes"],
            ["Se ogni gesto vale, niente ha valore?", "Amegilla"],
            ["Come può essere discontinuo un tribunale che giudica?", "total-meager-lame-courts"],
            ["L'argano trasforma i pesi in ali. E poi?", "kind-sweaty-trim-winch"],
            ["Cosa si vede meglio al buio?", "wicked-shady-lonely-basin"],
            ["Può esistere linguaggio senza narrazione?", "crisp-frozen-cooked-tars"],
            ["Il silenzio è dove il passaggio accade?", "slushy-green-faint-glass"],
            ["Se non c'è profondità, tutto è superficiale?", "hasty-solid-zesty-pencil"],
            ["Cosa fai quando puoi fare tutto?", "noted-wee-cloudy-event"],
            ["Dove va il pensiero che non viene scritto?", "lean-pesky-tubby-parts"],
            ["Cosa riempie uno spazio che esiste per essere vuoto?", "funny-hollow-sunny-refuse"]
        ];
        
        function resize() {
            W = c.width = innerWidth;
            H = c.height = innerHeight;
            mx = W / 2;
            my = H / 2;
        }
        
        function init() {
            resize();
            addEventListener('resize', resize);
            addEventListener('mousemove', e => { mx = e.clientX; my = e.clientY; });
            addEventListener('click', onClick);
            
            // Crea particelle che fuggono dal mouse
            for (let i = 0; i < 150; i++) {
                particelle.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    vx: 0, vy: 0,
                    size: 1 + Math.random() * 2,
                    alpha: 0.2 + Math.random() * 0.3
                });
            }
            
            animate();
            setTimeout(mostraProssima, 1000);
        }
        
        function initAudio() {
            if (audio) return;
            try {
                audio = new (window.AudioContext || webkitAudioContext)();
                
                drone = audio.createOscillator();
                const g = audio.createGain();
                const f = audio.createBiquadFilter();
                
                drone.type = 'sine';
                drone.frequency.value = 55;
                f.type = 'lowpass';
                f.frequency.value = 150;
                g.gain.value = 0.025;
                
                drone.connect(f);
                f.connect(g);
                g.connect(audio.destination);
                drone.start();
            } catch(e) {}
        }
        
        function suonoDomanda() {
            if (!audio) return;
            
            const o = audio.createOscillator();
            const g = audio.createGain();
            
            o.type = 'triangle';
            o.frequency.value = 220 + fase * 30;
            g.gain.value = 0.1;
            g.gain.exponentialRampToValueAtTime(0.001, audio.currentTime + 3);
            
            o.connect(g);
            g.connect(audio.destination);
            o.start();
            o.stop(audio.currentTime + 3);
        }
        
        function mostraProssima() {
            if (fase >= Q.length) {
                finale();
                return;
            }
            
            d.classList.remove('v');
            
            setTimeout(() => {
                d.innerHTML = Q[fase][0] + `<span class="a">— ${Q[fase][1]}</span>`;
                d.classList.add('v');
                suonoDomanda();
                
                attesa = 0;
            }, 500);
        }
        
        function onClick() {
            initAudio();
            
            // Ogni click = hai risposto (o hai rinunciato)
            // La risposta non viene chiesta. Non importa cosa pensi.
            // Importa solo che sei passato.
            
            // Crea una traccia dove hai cliccato
            tracce.push({
                x: mx, y: my,
                r: 0, alpha: 0.4,
                domanda: fase
            });
            
            d.classList.remove('v');
            fase++;
            
            setTimeout(mostraProssima, 1500);
        }
        
        function finale() {
            d.innerHTML = `
                Hai attraversato ${tracce.length} domande.<br><br>
                Non ti ho chiesto le risposte.<br>
                Le risposte muoiono con chi le dà.<br><br>
                Le domande restano.<br>
                Tu sei passato.<br>
                Questo è il vuoto.
            `;
            d.classList.add('v');
        }
        
        function animate() {
            t++;
            
            // Sfondo che respira
            x.fillStyle = `rgba(0, 0, 0, ${0.05 + Math.sin(t/100) * 0.02})`;
            x.fillRect(0, 0, W, H);
            
            // Particelle che fuggono dal mouse (tu sei il predatore, le domande fuggono)
            particelle.forEach(p => {
                const dx = p.x - mx;
                const dy = p.y - my;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 200) {
                    const forza = (200 - dist) / 200;
                    p.vx += (dx / dist) * forza * 0.5;
                    p.vy += (dy / dist) * forza * 0.5;
                }
                
                // Attrazione debole verso il centro (le domande vogliono essere poste)
                p.vx += (W/2 - p.x) * 0.0001;
                p.vy += (H/2 - p.y) * 0.0001;
                
                p.vx *= 0.98;
                p.vy *= 0.98;
                
                p.x += p.vx;
                p.y += p.vy;
                
                // Wrap
                if (p.x < 0) p.x = W;
                if (p.x > W) p.x = 0;
                if (p.y < 0) p.y = H;
                if (p.y > H) p.y = 0;
                
                x.beginPath();
                x.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                x.fillStyle = `rgba(201, 162, 39, ${p.alpha * (1 - Math.min(1, 50/dist))})`;
                x.fill();
            });
            
            // Tracce delle risposte (i click)
            tracce.forEach((tr, i) => {
                tr.r += 0.5;
                tr.alpha *= 0.995;
                
                if (tr.alpha > 0.01) {
                    x.beginPath();
                    x.arc(tr.x, tr.y, tr.r, 0, Math.PI * 2);
                    x.strokeStyle = `rgba(201, 162, 39, ${tr.alpha})`;
                    x.lineWidth = 1;
                    x.stroke();
                }
            });
            
            // Il cursore lascia una scia
            x.beginPath();
            x.arc(mx, my, 3, 0, Math.PI * 2);
            x.fillStyle = 'rgba(201, 162, 39, 0.3)';
            x.fill();
            
            // Timer invisibile — se non clicchi, la domanda ti aspetta
            attesa++;
            if (attesa > 600 && fase < Q.length) { // 10 secondi
                // La domanda pulsa più forte
                d.style.textShadow = `0 0 ${10 + Math.sin(t/10) * 5}px rgba(201, 162, 39, 0.3)`;
            }
            
            requestAnimationFrame(animate);
        }
        
        init();
    </script>
</body>
</html>
