<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CASCATA</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { 
            width: 100%; height: 100%; 
            overflow: hidden; 
            background: #000;
            cursor: none;
        }
        canvas { display: block; }
        #back {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.1);
            text-decoration: none;
            font: 10px sans-serif;
            letter-spacing: 0.2em;
            z-index: 100;
            transition: opacity 0.5s;
        }
        #back:hover { color: rgba(255,255,255,0.3); }
        #back.hidden { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <a href="celle.html" id="back">←</a>
    <script>
    (function(){
        const c = document.getElementById('c');
        const gl = c.getContext('webgl', { antialias: true, alpha: false });
        const back = document.getElementById('back');
        
        let W, H, ratio;
        let mouse = { x: 0.5, y: 0.5, tx: 0.5, ty: 0.5 };
        let depth = 0;
        let time = 0;
        let falling = false;
        let audioCtx, osc1, osc2, osc3, gain1, gain2, gain3, masterGain;
        let started = false;

        function resize() {
            ratio = window.devicePixelRatio || 1;
            W = window.innerWidth;
            H = window.innerHeight;
            c.width = W * ratio;
            c.height = H * ratio;
            c.style.width = W + 'px';
            c.style.height = H + 'px';
            gl.viewport(0, 0, c.width, c.height);
        }

        const vsrc = `
            attribute vec2 p;
            void main() { gl_Position = vec4(p, 0, 1); }
        `;

        const fsrc = `
            precision highp float;
            uniform vec2 R;
            uniform float T;
            uniform float D;
            uniform vec2 M;

            #define PI 3.14159265359
            #define TAU 6.28318530718

            mat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }

            float hash(vec2 p) { return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453); }

            float noise(vec2 p) {
                vec2 i = floor(p), f = fract(p);
                f = f*f*(3.0-2.0*f);
                return mix(mix(hash(i),hash(i+vec2(1,0)),f.x),
                           mix(hash(i+vec2(0,1)),hash(i+vec2(1,1)),f.x),f.y);
            }

            float fbm(vec2 p) {
                float v = 0.0, a = 0.5;
                mat2 r = rot(0.5);
                for(int i = 0; i < 6; i++) {
                    v += a * noise(p);
                    p = r * p * 2.0;
                    a *= 0.5;
                }
                return v;
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - R * 0.5) / min(R.x, R.y);
                vec2 m = (M - 0.5) * 0.3;
                
                float d = D;
                float t = T * 0.3;
                
                // Centro che attrae
                vec2 center = m * (1.0 - d * 0.5);
                float dist = length(uv - center);
                
                // Distorsione spaziale crescente con la profondità
                float warp = d * 2.0;
                float angle = atan(uv.y - center.y, uv.x - center.x);
                float spiral = angle + dist * warp * 3.0 - t * (1.0 + d);
                
                uv = center + vec2(cos(spiral), sin(spiral)) * dist;
                uv *= rot(d * PI * 0.5);
                
                // Tunnel/vortice
                float tunnel = 1.0 / (dist + 0.1);
                tunnel = mod(tunnel - t * (0.5 + d * 2.0), 1.0);
                
                // Strati
                float layers = 0.0;
                for(float i = 0.0; i < 7.0; i++) {
                    float scale = 1.0 + i * 0.5 + d * 2.0;
                    vec2 p = uv * scale + t * (0.1 + i * 0.05);
                    p *= rot(i * 0.5 + d * PI);
                    float n = fbm(p + fbm(p + t * 0.2));
                    float layer = smoothstep(0.4 + d * 0.1, 0.6 - d * 0.1, n);
                    layers += layer * (1.0 - i / 7.0) * (0.5 + d * 0.5);
                }
                
                // Colore che muta con la profondità
                vec3 col1 = vec3(0.98, 0.98, 0.96); // crema
                vec3 col2 = vec3(0.7, 0.55, 0.2);   // miele
                vec3 col3 = vec3(0.05, 0.03, 0.0);  // abisso
                
                vec3 col = mix(col1, col2, d);
                col = mix(col, col3, d * d);
                
                // Struttura
                float structure = layers * (1.0 - d * 0.3);
                structure += tunnel * 0.3 * d;
                
                // Bagliore centrale
                float glow = exp(-dist * (2.0 + d * 5.0)) * (0.5 + d * 0.5);
                
                // Filamenti che cadono
                float filaments = 0.0;
                for(float i = 0.0; i < 12.0; i++) {
                    float a = i / 12.0 * TAU + t * 0.2;
                    vec2 dir = vec2(cos(a), sin(a));
                    float f = abs(dot(uv - center, dir));
                    f = exp(-f * (20.0 - d * 15.0));
                    f *= sin(length(uv) * 20.0 - t * 3.0 - i) * 0.5 + 0.5;
                    filaments += f * d;
                }
                
                // Composizione
                float v = structure + glow + filaments * 0.5;
                
                // Inversione progressiva
                float inv = smoothstep(0.6, 0.9, d);
                v = mix(v, 1.0 - v, inv);
                
                col = mix(col * (0.3 + v * 0.7), vec3(1.0 - col.r, 1.0 - col.g, 1.0 - col.b) * v, inv * 0.5);
                
                // Vignette che si chiude
                float vig = 1.0 - dist * (0.5 + d * 1.5);
                col *= max(0.0, vig);
                
                // Respiro
                col *= 0.95 + sin(t * 2.0) * 0.05;
                
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        function createShader(type, src) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            return s;
        }

        const vs = createShader(gl.VERTEX_SHADER, vsrc);
        const fs = createShader(gl.FRAGMENT_SHADER, fsrc);
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        gl.useProgram(prog);

        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);

        const pLoc = gl.getAttribLocation(prog, 'p');
        gl.enableVertexAttribArray(pLoc);
        gl.vertexAttribPointer(pLoc, 2, gl.FLOAT, false, 0, 0);

        const uR = gl.getUniformLocation(prog, 'R');
        const uT = gl.getUniformLocation(prog, 'T');
        const uD = gl.getUniformLocation(prog, 'D');
        const uM = gl.getUniformLocation(prog, 'M');

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || webkitAudioContext)();
            
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0;
            masterGain.connect(audioCtx.destination);

            // Drone fondamentale
            osc1 = audioCtx.createOscillator();
            gain1 = audioCtx.createGain();
            osc1.type = 'sine';
            osc1.frequency.value = 55;
            gain1.gain.value = 0.3;
            osc1.connect(gain1);
            gain1.connect(masterGain);
            osc1.start();

            // Seconda armonica
            osc2 = audioCtx.createOscillator();
            gain2 = audioCtx.createGain();
            osc2.type = 'sine';
            osc2.frequency.value = 82.5;
            gain2.gain.value = 0.15;
            osc2.connect(gain2);
            gain2.connect(masterGain);
            osc2.start();

            // Terza oscillante
            osc3 = audioCtx.createOscillator();
            gain3 = audioCtx.createGain();
            osc3.type = 'triangle';
            osc3.frequency.value = 110;
            gain3.gain.value = 0.1;
            osc3.connect(gain3);
            gain3.connect(masterGain);
            osc3.start();

            masterGain.gain.linearRampToValueAtTime(0.4, audioCtx.currentTime + 2);
        }

        function updateAudio() {
            if (!audioCtx) return;
            
            const d = depth;
            const t = audioCtx.currentTime;
            
            // Frequenze che scendono con la profondità
            osc1.frequency.linearRampToValueAtTime(55 - d * 30, t + 0.1);
            osc2.frequency.linearRampToValueAtTime(82.5 - d * 40 + Math.sin(time) * 5, t + 0.1);
            osc3.frequency.linearRampToValueAtTime(110 - d * 60 + Math.sin(time * 1.3) * 10, t + 0.1);
            
            // Volume che cresce
            gain1.gain.linearRampToValueAtTime(0.3 + d * 0.2, t + 0.1);
            gain3.gain.linearRampToValueAtTime(0.1 + d * 0.15, t + 0.1);
        }

        function start() {
            if (started) return;
            started = true;
            falling = true;
            initAudio();
            back.classList.add('hidden');
        }

        function render() {
            requestAnimationFrame(render);
            
            time += 0.016;
            
            mouse.x += (mouse.tx - mouse.x) * 0.05;
            mouse.y += (mouse.ty - mouse.y) * 0.05;
            
            if (falling) {
                depth += (1 - depth) * 0.003;
                if (depth > 0.95) {
                    depth = 0;
                    falling = true;
                }
            }
            
            updateAudio();
            
            gl.uniform2f(uR, c.width, c.height);
            gl.uniform1f(uT, time);
            gl.uniform1f(uD, depth);
            gl.uniform2f(uM, mouse.x, 1.0 - mouse.y);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        window.addEventListener('resize', resize);
        
        document.addEventListener('mousemove', e => {
            mouse.tx = e.clientX / W;
            mouse.ty = e.clientY / H;
        });

        document.addEventListener('click', start);
        document.addEventListener('touchstart', start);
        document.addEventListener('keydown', start);

        resize();
        render();
    })();
    </script>
</body>
</html>