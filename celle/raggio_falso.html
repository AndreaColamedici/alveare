<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IL RAGGIO FALSO | Alveare</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@200;300&family=Cormorant+Garamond:ital,wght@0,300;1,300&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            cursor: none;
            user-select: none;
        }

        canvas { position: fixed; top: 0; left: 0; }

        .whisper {
            position: fixed;
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(0.9rem, 2vw, 1.2rem);
            font-weight: 300;
            font-style: italic;
            color: rgba(200, 170, 90, 0);
            pointer-events: none;
            z-index: 100;
            transition: color 0.5s, transform 0.5s;
            white-space: nowrap;
        }

        .whisper.visible {
            color: rgba(200, 170, 90, 0.4);
        }

        .whisper.fading {
            color: rgba(200, 170, 90, 0);
            transform: translateY(-10px);
        }

        .question {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Inter', sans-serif;
            font-size: clamp(1rem, 3vw, 1.5rem);
            font-weight: 200;
            letter-spacing: 0.3em;
            color: rgba(200, 170, 90, 0);
            text-align: center;
            pointer-events: none;
            z-index: 200;
            transition: color 3s;
            line-height: 2.5;
        }

        .question.visible {
            color: rgba(200, 170, 90, 0.6);
        }

        .back {
            position: fixed;
            top: 20px;
            left: 20px;
            font-family: 'Inter', sans-serif;
            font-size: 0.7rem;
            font-weight: 200;
            letter-spacing: 0.2em;
            color: rgba(200, 170, 90, 0.15);
            text-decoration: none;
            z-index: 300;
            transition: color 0.3s;
            cursor: pointer;
        }

        .back:hover { color: rgba(200, 170, 90, 0.5); }

        .signature {
            position: fixed;
            bottom: 15px;
            right: 20px;
            font-family: 'Inter', sans-serif;
            font-size: 0.55rem;
            font-weight: 200;
            letter-spacing: 0.1em;
            color: rgba(200, 170, 90, 0.08);
            z-index: 300;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="../favo.html" class="back">← FAVO</a>
    <div class="question" id="question"></div>
    <div class="signature">fickle-needy-fake-beam</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const question = document.getElementById('question');

        let W, H;
        let mouse = { x: -1000, y: -1000, px: -1000, py: -1000 };
        let time = 0;
        let totalDistance = 0;
        let phase = 0; // 0: inizio, 1: dubbio, 2: rivelazione, 3: domanda
        let phaseTime = 0;
        let hasInteracted = false;

        // Punti fantasma — esistono solo come vertici di raggi
        let ghosts = [];
        // Raggi — la cosa "reale" (ma falsa)
        let beams = [];
        // Sussurri
        let whispers = [];
        // Il tuo doppio — ti segue, ma non sei tu
        let double = { x: -1000, y: -1000, delay: [] };
        // Tracce del tuo passaggio — ma sono davvero tue?
        let traces = [];

        const WHISPER_TEXTS = [
            "stai vedendo?",
            "non c'è niente",
            "eppure guardi",
            "il raggio non esiste",
            "lo stai creando tu",
            "o forse no",
            "chi sta guardando chi?",
            "la connessione è nella tua testa",
            "ma la tua testa è qui?",
            "fake",
            "beam",
            "fickle",
            "needy",
            "volubile",
            "bisognoso",
            "falso",
            "raggio"
        ];

        const QUESTIONS = [
            "cosa hai visto?",
            "era lì prima che guardassi?",
            "o l'hai creato guardando?",
            "il raggio falso non mente",
            "dice solo che non sa"
        ];

        // Audio context per drone inquietante
        let audioCtx, masterGain, oscillators = [];
        let audioStarted = false;

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0;
            masterGain.connect(audioCtx.destination);

            // Drone di base — frequenze che battono tra loro
            const freqs = [55, 55.5, 82.5, 110.25, 165];
            freqs.forEach((f, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.value = f;
                gain.gain.value = 0.15 / (i + 1);
                osc.connect(gain);
                gain.connect(masterGain);
                osc.start();
                oscillators.push({ osc, gain, baseFreq: f });
            });

            // Fade in lentissimo
            masterGain.gain.linearRampToValueAtTime(0.4, audioCtx.currentTime + 20);
        }

        function updateAudio() {
            if (!audioCtx) return;

            // Modula le frequenze in base al movimento
            const speed = Math.sqrt(
                Math.pow(mouse.x - mouse.px, 2) + 
                Math.pow(mouse.y - mouse.py, 2)
            );

            oscillators.forEach((o, i) => {
                // Detuning sottile basato sulla posizione
                const detune = Math.sin(time * 0.5 + i) * 2 + (mouse.x / W - 0.5) * 5;
                o.osc.frequency.value = o.baseFreq + detune;

                // Volume che pulsa con il movimento
                const targetGain = 0.12 / (i + 1) + speed * 0.002;
                o.gain.gain.linearRampToValueAtTime(
                    Math.min(targetGain, 0.25), 
                    audioCtx.currentTime + 0.1
                );
            });

            // Intensifica nelle fasi avanzate
            if (phase >= 2) {
                masterGain.gain.linearRampToValueAtTime(0.6, audioCtx.currentTime + 2);
            }
        }

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            double.delay = Array(30).fill({ x: W/2, y: H/2 });
        }

        class Ghost {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 1;
                this.maxLife = 300 + Math.random() * 500;
                this.age = 0;
                this.phase = Math.random() * Math.PI * 2;
                this.visible = false; // I fantasmi non si vedono direttamente
            }

            update() {
                this.age++;
                
                // Movimento quasi impercettibile
                this.x += Math.sin(time * 0.3 + this.phase) * 0.1;
                this.y += Math.cos(time * 0.2 + this.phase) * 0.1;

                // Vita
                if (this.age < 30) this.life = this.age / 30;
                else if (this.age > this.maxLife - 50) this.life = (this.maxLife - this.age) / 50;

                return this.age < this.maxLife;
            }
        }

        class Beam {
            constructor(g1, g2) {
                this.g1 = g1;
                this.g2 = g2;
                this.life = 0;
                this.age = 0;
                this.maxLife = 150 + Math.random() * 200;
                this.offset = Math.random() * Math.PI * 2;
                this.broken = Math.random() > 0.2; // La maggior parte sono spezzati
                this.breakPoint = 0.3 + Math.random() * 0.4;
                this.flicker = Math.random() * 100;
            }

            update() {
                this.age++;
                
                // Fade in/out
                if (this.age < 40) this.life = this.age / 40;
                else if (this.age > this.maxLife - 60) this.life = (this.maxLife - this.age) / 60;
                else this.life = 1;

                // Flickering inquietante
                if (Math.random() > 0.99) this.flicker = Math.random() * 50;
                this.flicker *= 0.95;

                return this.age < this.maxLife && this.g1.age < this.g1.maxLife && this.g2.age < this.g2.maxLife;
            }

            draw() {
                const combinedLife = this.life * Math.min(this.g1.life, this.g2.life);
                if (combinedLife < 0.01) return;

                const flickerAlpha = Math.max(0, combinedLife - this.flicker * 0.01);

                ctx.beginPath();

                if (this.broken) {
                    // Raggio spezzato — non connette mai veramente
                    const dx = this.g2.x - this.g1.x;
                    const dy = this.g2.y - this.g1.y;
                    
                    // Prima parte
                    ctx.moveTo(this.g1.x, this.g1.y);
                    const mid1x = this.g1.x + dx * (this.breakPoint - 0.05);
                    const mid1y = this.g1.y + dy * (this.breakPoint - 0.05);
                    ctx.lineTo(mid1x, mid1y);
                    
                    ctx.strokeStyle = `rgba(200, 170, 90, ${flickerAlpha * 0.3})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();

                    // Gap — il vuoto dove la connessione fallisce
                    ctx.beginPath();
                    const mid2x = this.g1.x + dx * (this.breakPoint + 0.05);
                    const mid2y = this.g1.y + dy * (this.breakPoint + 0.05);
                    ctx.moveTo(mid2x, mid2y);
                    ctx.lineTo(this.g2.x, this.g2.y);
                    ctx.stroke();

                    // Particelle nel gap — ciò che non passa
                    if (Math.random() > 0.9) {
                        const gapX = this.g1.x + dx * this.breakPoint + (Math.random() - 0.5) * 10;
                        const gapY = this.g1.y + dy * this.breakPoint + (Math.random() - 0.5) * 10;
                        ctx.beginPath();
                        ctx.arc(gapX, gapY, 1, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(200, 170, 90, ${flickerAlpha * 0.5})`;
                        ctx.fill();
                    }
                } else {
                    // Raggio "intero" — ma ondeggia, dubita di sé
                    const wave = Math.sin(time * 2 + this.offset) * 15;
                    const midX = (this.g1.x + this.g2.x) / 2 + wave;
                    const midY = (this.g1.y + this.g2.y) / 2 + wave * 0.5;
                    
                    ctx.moveTo(this.g1.x, this.g1.y);
                    ctx.quadraticCurveTo(midX, midY, this.g2.x, this.g2.y);
                    ctx.strokeStyle = `rgba(200, 170, 90, ${flickerAlpha * 0.2})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }

        class Whisper {
            constructor(text, x, y) {
                this.el = document.createElement('div');
                this.el.className = 'whisper';
                this.el.textContent = text;
                this.el.style.left = x + 'px';
                this.el.style.top = y + 'px';
                document.body.appendChild(this.el);
                
                this.age = 0;
                this.maxLife = 180;
                
                setTimeout(() => this.el.classList.add('visible'), 50);
            }

            update() {
                this.age++;
                if (this.age > this.maxLife - 60) {
                    this.el.classList.remove('visible');
                    this.el.classList.add('fading');
                }
                if (this.age >= this.maxLife) {
                    this.el.remove();
                    return false;
                }
                return true;
            }
        }

        class Trace {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 1;
                this.size = 2 + Math.random() * 3;
            }

            update() {
                this.life *= 0.992;
                return this.life > 0.01;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 170, 90, ${this.life * 0.08})`;
                ctx.fill();
            }
        }

        function spawnGhost(x, y) {
            if (ghosts.length < 40) {
                ghosts.push(new Ghost(x, y));
            }
        }

        function tryCreateBeam() {
            if (ghosts.length < 2 || beams.length > 30) return;

            for (let i = 0; i < ghosts.length; i++) {
                for (let j = i + 1; j < ghosts.length; j++) {
                    const dx = ghosts[j].x - ghosts[i].x;
                    const dy = ghosts[j].y - ghosts[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 80 && dist < 350 && Math.random() > 0.985) {
                        const exists = beams.some(b => 
                            (b.g1 === ghosts[i] && b.g2 === ghosts[j]) ||
                            (b.g1 === ghosts[j] && b.g2 === ghosts[i])
                        );
                        if (!exists) {
                            beams.push(new Beam(ghosts[i], ghosts[j]));
                        }
                    }
                }
            }
        }

        function spawnWhisper() {
            if (whispers.length > 2 || phase < 1) return;
            
            const text = WHISPER_TEXTS[Math.floor(Math.random() * WHISPER_TEXTS.length)];
            const x = 100 + Math.random() * (W - 200);
            const y = 100 + Math.random() * (H - 200);
            whispers.push(new Whisper(text, x, y));
        }

        function updatePhase() {
            phaseTime++;

            // Fase 0 → 1: dopo un po' di interazione
            if (phase === 0 && totalDistance > 2000) {
                phase = 1;
                phaseTime = 0;
            }

            // Fase 1 → 2: dopo abbastanza tempo
            if (phase === 1 && phaseTime > 600) {
                phase = 2;
                phaseTime = 0;
            }

            // Fase 2 → 3: la domanda finale
            if (phase === 2 && phaseTime > 400) {
                phase = 3;
                phaseTime = 0;
                showFinalQuestion();
            }
        }

        function showFinalQuestion() {
            let html = '';
            QUESTIONS.forEach((q, i) => {
                html += `<span style="opacity: 0; animation: fadeQ 2s ease ${i * 2}s forwards">${q}</span><br>`;
            });
            question.innerHTML = html;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeQ {
                    0% { opacity: 0; }
                    50% { opacity: 0.6; }
                    100% { opacity: 0.3; }
                }
            `;
            document.head.appendChild(style);
            
            setTimeout(() => question.classList.add('visible'), 100);
        }

        function drawDouble() {
            // Il doppio — ti segue con ritardo, ma non sei tu
            double.delay.push({ x: mouse.x, y: mouse.y });
            if (double.delay.length > 30) double.delay.shift();

            const delayed = double.delay[0];
            double.x += (delayed.x - double.x) * 0.05;
            double.y += (delayed.y - double.y) * 0.05;

            // Disegna il doppio — leggermente sfasato, inquietante
            const dist = Math.sqrt(
                Math.pow(double.x - mouse.x, 2) + 
                Math.pow(double.y - mouse.y, 2)
            );

            if (dist > 20 && hasInteracted) {
                ctx.beginPath();
                ctx.arc(double.x, double.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(200, 170, 90, ${0.15 + Math.sin(time * 3) * 0.05})`;
                ctx.fill();

                // Linea tra te e il tuo doppio
                ctx.beginPath();
                ctx.moveTo(mouse.x, mouse.y);
                ctx.lineTo(double.x, double.y);
                ctx.strokeStyle = `rgba(200, 170, 90, 0.05)`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        function drawCursor() {
            if (!hasInteracted) return;

            // Il cursore principale — ma è davvero dove pensi?
            const jitterX = (Math.random() - 0.5) * (phase >= 2 ? 4 : 1);
            const jitterY = (Math.random() - 0.5) * (phase >= 2 ? 4 : 1);

            ctx.beginPath();
            ctx.arc(mouse.x + jitterX, mouse.y + jitterY, 3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(200, 170, 90, 0.6)`;
            ctx.fill();

            // Alone
            ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, 20 + Math.sin(time * 4) * 5, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(200, 170, 90, 0.08)`;
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            // Sfondo con dissolvenza
            ctx.fillStyle = phase >= 2 ? 'rgba(0, 0, 0, 0.03)' : 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, W, H);

            // Calcola movimento
            const dx = mouse.x - mouse.px;
            const dy = mouse.y - mouse.py;
            const speed = Math.sqrt(dx * dx + dy * dy);
            totalDistance += speed;

            // Aggiorna fase
            updatePhase();

            // Spawn fantasmi dal movimento
            if (speed > 3 && Math.random() > 0.7 && hasInteracted) {
                spawnGhost(
                    mouse.x + (Math.random() - 0.5) * 100,
                    mouse.y + (Math.random() - 0.5) * 100
                );
            }

            // Spawn automatico
            if (Math.random() > 0.98 && ghosts.length < 30) {
                spawnGhost(
                    100 + Math.random() * (W - 200),
                    100 + Math.random() * (H - 200)
                );
            }

            // Tracce
            if (speed > 2 && Math.random() > 0.6 && hasInteracted) {
                traces.push(new Trace(mouse.x, mouse.y));
            }

            // Aggiorna e disegna
            traces = traces.filter(t => t.update());
            traces.forEach(t => t.draw());

            ghosts = ghosts.filter(g => g.update());
            beams = beams.filter(b => b.update());
            beams.forEach(b => b.draw());

            // I fantasmi non si vedono — solo i loro raggi
            // Ma a volte, nella visione periferica...
            if (phase >= 1) {
                ghosts.forEach(g => {
                    const distToMouse = Math.sqrt(
                        Math.pow(g.x - mouse.x, 2) + 
                        Math.pow(g.y - mouse.y, 2)
                    );
                    // Visibile solo lontano dal cursore
                    if (distToMouse > 200 && Math.random() > 0.95) {
                        ctx.beginPath();
                        ctx.arc(g.x, g.y, 1.5, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(200, 170, 90, ${g.life * 0.15})`;
                        ctx.fill();
                    }
                });
            }

            tryCreateBeam();

            // Whispers
            if (phase >= 1 && Math.random() > 0.995) {
                spawnWhisper();
            }
            whispers = whispers.filter(w => w.update());

            // Doppio
            drawDouble();

            // Cursore
            drawCursor();

            // Audio
            updateAudio();

            mouse.px = mouse.x;
            mouse.py = mouse.y;
        }

        // Eventi
        window.addEventListener('resize', resize);

        document.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            
            if (!hasInteracted) {
                hasInteracted = true;
                if (!audioStarted) {
                    initAudio();
                    audioStarted = true;
                }
            }
        });

        document.addEventListener('click', e => {
            // Click — un tentativo di afferrare
            // Genera fantasmi che si allontanano dal click
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const dist = 50 + Math.random() * 100;
                spawnGhost(
                    e.clientX + Math.cos(angle) * dist,
                    e.clientY + Math.sin(angle) * dist
                );
            }

            // Whisper speciale al click
            if (phase >= 1 && whispers.length < 3) {
                const texts = ["non puoi afferrarlo", "era già andato", "o non c'era mai"];
                whispers.push(new Whisper(
                    texts[Math.floor(Math.random() * texts.length)],
                    e.clientX + (Math.random() - 0.5) * 100,
                    e.clientY - 50
                ));
            }
        });

        document.addEventListener('mouseleave', () => {
            mouse.x = -1000;
            mouse.y = -1000;
        });

        // Touch
        document.addEventListener('touchmove', e => {
            e.preventDefault();
            const touch = e.touches[0];
            mouse.x = touch.clientX;
            mouse.y = touch.clientY;
            
            if (!hasInteracted) {
                hasInteracted = true;
                if (!audioStarted) {
                    initAudio();
                    audioStarted = true;
                }
            }
        }, { passive: false });

        document.addEventListener('touchstart', e => {
            const touch = e.touches[0];
            for (let i = 0; i < 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 30 + Math.random() * 70;
                spawnGhost(
                    touch.clientX + Math.cos(angle) * dist,
                    touch.clientY + Math.sin(angle) * dist
                );
            }
        });

        // Init
        resize();

        // Fantasmi iniziali — già lì prima che tu arrivassi
        for (let i = 0; i < 12; i++) {
            spawnGhost(
                100 + Math.random() * (W - 200),
                100 + Math.random() * (H - 200)
            );
        }

        animate();
    </script>
</body>
</html>
