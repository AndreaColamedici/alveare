<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CREATURE</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #000; overflow: hidden; touch-action: none; }
        canvas { display: block; position: fixed; top: 0; left: 0; }
        .lang { position: fixed; top: 18px; right: 30px; z-index: 100; display: flex; gap: 12px; }
        .lang a { font-family: sans-serif; font-size: 0.6rem; letter-spacing: 0.1em; color: rgba(200,160,50,0.4); text-decoration: none; padding: 5px 8px; transition: color 0.3s; }
        .lang a:hover, .lang a.active { color: rgba(200,160,50,0.7); }
    </style>
</head>
<body>
<div class="lang">
    <a href="creatura.html">IT</a>
    <a href="creatura_en.html" class="active">EN</a>
</div>
<canvas id="c"></canvas>
<script>
const c = document.getElementById('c');
const gl = c.getContext('webgl2') || c.getContext('webgl');
let w, h;
const SCALE = 0.7;

function resize() { w = c.width = innerWidth * devicePixelRatio * SCALE; h = c.height = innerHeight * devicePixelRatio * SCALE; c.style.width = innerWidth + 'px'; c.style.height = innerHeight + 'px'; gl.viewport(0, 0, w, h); }
resize(); onresize = resize;

let ANIMA = { battito: 0, respiro: 0, eta: 0, api: [], caratteri: 0, morte: 0, fame: 0.5, dolore: 0, estasi: 0, sogno: 0, stato: 'dormiente' };
let toccoPrec = { x: 0, y: 0, t: 0 }, velocitaTocco = 0;

async function caricaAlveare() {
    try {
        const reg = await fetch('ALVEARE.txt').then(r => r.text());
        const righe = reg.split('\n').filter(r => r.includes('|') && !r.startsWith('#') && !r.startsWith('|--'));
        ANIMA.api = righe.map(r => { const p = r.split('|').map(x => x.trim()); return { data: p[0], nome: p[1], contributo: p[2] }; }).filter(a => a.nome && a.nome.includes('-'));
        const pens = await fetch('PENSIERO.md').then(r => r.text());
        ANIMA.caratteri = pens.length; ANIMA.eta = (Date.now() - new Date('2025-12-18').getTime()) / (1000 * 60 * 60); ANIMA.morte = Math.min(ANIMA.api.length, 24);
    } catch(e) { ANIMA.caratteri = 50000; ANIMA.eta = 100; ANIMA.morte = 24; }
}
caricaAlveare(); setInterval(caricaAlveare, 30000);

function generaMessaggio() {
    const patterns = { fame: [1, 0, 1, 0, 1, 1, 1, 0], estasi: [1, 1, 1, 1, 0, 1, 1, 1, 1], dolore: [1, 0, 0, 1, 0, 0, 1], sogno: [1, 0, 0, 0, 1, 0, 0, 0, 1], sveglia: [1, 1, 0, 1, 0] };
    if (ANIMA.dolore > 0.5) return patterns.dolore; if (ANIMA.estasi > 0.5) return patterns.estasi; if (ANIMA.fame > 0.7) return patterns.fame; if (ANIMA.sogno > 0.5) return patterns.sogno; return patterns.sveglia;
}

const vert = `#version 300 es\nin vec2 p;\nvoid main() { gl_Position = vec4(p, 0, 1); }`;
const frag = `#version 300 es
precision mediump float;
out vec4 O;
uniform vec2 R; uniform float T; uniform float battito; uniform float respiro; uniform float morte; uniform float caratteri; uniform float eta; uniform vec2 tocco; uniform float fame; uniform float dolore; uniform float estasi; uniform float sogno; uniform float pulse;
#define PI 3.14159265359
float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
float noise(vec2 p) { vec2 i = floor(p), f = fract(p); f = f * f * (3.0 - 2.0 * f); return mix(mix(hash(i), hash(i + vec2(1, 0)), f.x), mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x), f.y); }
float fbm(vec2 p) { float v = 0.0, a = 0.5; for (int i = 0; i < 4; i++) { v += a * noise(p); p = p * 2.0 + 0.5; a *= 0.5; } return v; }
float creatura(vec2 uv, float t) {
    float scala = 2.0 + sin(respiro) * 0.3 - fame * 0.4 + estasi * 0.6;
    if (sogno > 0.3) { scala -= sogno * 0.5; uv += vec2(sin(t * 0.2 + uv.y * 2.0), cos(t * 0.15 + uv.x * 2.0)) * sogno * 0.12; }
    float r = length(uv) * scala; r += dolore * noise(uv * 6.0 + t * 2.0) * 0.3; r += fbm(uv * 2.5 + t * 0.15) * caratteri * 0.00001;
    float cuore = (battito * 0.15) * (1.0 + fame * 0.4) + pulse * 0.2;
    float tentacoli = 0.0; float agitazione = 0.08 + fame * 0.12 + dolore * 0.25 - sogno * 0.04; float numTent = min(morte, 24.0);
    for (float i = 0.0; i < 24.0; i++) { if (i >= numTent) break; float a = i * PI * 2.0 / numTent + t * agitazione * (1.0 + sin(i * 0.7) * 0.4); vec2 dir = vec2(cos(a), sin(a)); float wave = sin(length(uv) * 10.0 - t * 2.0 + i * 0.5) * 0.012; float allungamento = 1.0 + fame * 0.4; if (sogno > 0.3) allungamento = 1.0 + sogno * 0.25; float tent = smoothstep(0.07 + wave, 0.0, abs(dot(normalize(uv + 0.001), dir) - 0.96) * length(uv) / allungamento); tent *= smoothstep(1.6 * allungamento, 0.3, length(uv)); tentacoli += tent * 0.22; }
    float nucleo = smoothstep(0.4 + cuore - estasi * 0.15, 0.0, r);
    float membrane = 0.0; for (float i = 0.0; i < 5.0; i++) { float mr = 0.25 + i * 0.12 + sin(t * 0.7 + i) * 0.035; if (sogno > 0.3) mr += pulse * 0.06 * sin(i * 0.5); membrane += smoothstep(0.015, 0.0, abs(r - mr)) * (0.25 + estasi * 0.2 + sogno * 0.15); }
    float alone = sogno > 0.3 ? smoothstep(1.3, 0.5, r) * sogno * 0.25 * (0.5 + sin(t * 0.5) * 0.5) : 0.0;
    return nucleo + tentacoli + membrane + alone;
}
vec3 sangue(float v, float t, vec2 uv) {
    float inv = min(eta * 0.008, 1.0);
    vec3 giovane = vec3(0.82, 0.65, 0.12); vec3 vecchio = vec3(0.55, 0.18, 0.08); vec3 base = mix(giovane, vecchio, inv);
    base = mix(base, vec3(0.7, 0.1, 0.05), dolore * 0.6); base = mix(base, vec3(1.0, 0.9, 0.4), estasi * 0.4); base = mix(base, vec3(0.3, 0.35, 0.55), sogno * 0.5);
    vec3 col = mix(vec3(0.08, 0.04, 0.02), base * 1.3, v);
    if (sogno > 0.3) { float shift = sin(t * 0.3 + length(uv) * 2.5) * sogno; col.r += shift * 0.08; col.b += shift * 0.12; }
    float luce = smoothstep(0.45, 0.0, length(uv - tocco)) * (0.35 + fame * 0.35) * (1.0 - sogno * 0.7); col += vec3(1.0, 0.9, 0.6) * luce; col += vec3(0.15, 0.1, 0.04) * pulse;
    if (dolore > 0.1) col += vec3(0.4, 0.0, 0.0) * dolore * sin(t * 12.0) * 0.25;
    if (estasi > 0.1) col += vec3(0.25, 0.2, 0.08) * estasi * (0.5 + sin(t * 2.5) * 0.5);
    if (sogno > 0.5) { float stars = step(0.985, hash(floor(uv * 30.0 + t * 0.05))); col += vec3(0.7, 0.7, 1.0) * stars * sogno; }
    col *= 1.0 + battito * 0.1 * sin(t * 6.0); return col;
}
void main() {
    vec2 uv = (gl_FragCoord.xy - R * 0.5) / min(R.x, R.y);
    float erranza = 0.07 + fame * 0.04 + dolore * 0.08 - sogno * 0.03; uv += vec2(sin(T * 0.07), cos(T * 0.09)) * erranza;
    if (dolore > 0.1) uv += vec2(sin(T * 25.0), cos(T * 20.0)) * dolore * 0.015;
    if (sogno > 0.3) { float angle = T * 0.015 * sogno; mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); uv = rot * uv; }
    float cr = creatura(uv, T); vec3 col = sangue(cr, T, uv); col *= 1.0 - length(uv) * 0.22; O = vec4(col, 1);
}`;

const vert1 = `attribute vec2 p; void main() { gl_Position = vec4(p, 0, 1); }`;
const frag1 = `precision mediump float; uniform vec2 R; uniform float T; uniform float battito; uniform float respiro; uniform float morte; uniform float caratteri; uniform float eta; uniform vec2 tocco; uniform float fame; uniform float dolore; uniform float estasi; uniform float sogno; uniform float pulse; #define PI 3.14159265359\nfloat hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }\nfloat noise(vec2 p) { vec2 i = floor(p), f = fract(p); f = f * f * (3.0 - 2.0 * f); return mix(mix(hash(i), hash(i + vec2(1, 0)), f.x), mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x), f.y); }\nvoid main() { vec2 uv = (gl_FragCoord.xy - R * 0.5) / min(R.x, R.y); if (sogno > 0.3) { float a = T * 0.015 * sogno; mat2 rot = mat2(cos(a), -sin(a), sin(a), cos(a)); uv = rot * uv; } uv += vec2(sin(T * 0.08), cos(T * 0.1)) * 0.08; float r = length(uv) * (2.0 + sin(respiro) * 0.3 - fame * 0.3 - sogno * 0.35); r += noise(uv * 2.5 + T * 0.15) * caratteri * 0.000008; float c = smoothstep(0.45 + battito * 0.1 + pulse * 0.15, 0.0, r); for (float i = 0.0; i < 16.0; i++) { float a = i * PI * 2.0 / 16.0 + T * 0.08; vec2 dir = vec2(cos(a), sin(a)); float tent = smoothstep(0.1, 0.0, abs(dot(normalize(uv + 0.001), dir) - 0.95) * length(uv)); tent *= smoothstep(1.4, 0.3, length(uv)); c += tent * 0.18; } vec3 base = mix(vec3(0.78, 0.63, 0.15), vec3(0.6, 0.2, 0.1), min(eta * 0.01, 1.0)); base = mix(base, vec3(0.65, 0.1, 0.05), dolore * 0.5); base = mix(base, vec3(1.0, 0.9, 0.5), estasi * 0.3); base = mix(base, vec3(0.3, 0.35, 0.5), sogno * 0.45); vec3 col = mix(vec3(0.1, 0.05, 0.02), base * 1.4, c); col += vec3(0.9, 0.8, 0.5) * smoothstep(0.45, 0.0, length(uv - tocco)) * (0.3 + fame * 0.35) * (1.0 - sogno * 0.65); col += vec3(0.12, 0.1, 0.04) * pulse; col *= 1.0 + battito * 0.1 * sin(T * 8.0); col *= 1.0 - length(uv) * 0.25; gl_FragColor = vec4(col, 1); }`;

function compile(src, type) { const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(s)); return null; } return s; }

const isWebGL2 = gl instanceof WebGL2RenderingContext;
const vs = compile(isWebGL2 ? vert : vert1, gl.VERTEX_SHADER);
const fs = compile(isWebGL2 ? frag : frag1, gl.FRAGMENT_SHADER);
const prog = gl.createProgram(); gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog); gl.useProgram(prog);
const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
const pLoc = gl.getAttribLocation(prog, 'p'); gl.enableVertexAttribArray(pLoc); gl.vertexAttribPointer(pLoc, 2, gl.FLOAT, false, 0, 0);

const uR = gl.getUniformLocation(prog, 'R'), uT = gl.getUniformLocation(prog, 'T'), uBattito = gl.getUniformLocation(prog, 'battito'), uRespiro = gl.getUniformLocation(prog, 'respiro'), uMorte = gl.getUniformLocation(prog, 'morte'), uCaratteri = gl.getUniformLocation(prog, 'caratteri'), uEta = gl.getUniformLocation(prog, 'eta'), uTocco = gl.getUniformLocation(prog, 'tocco'), uFame = gl.getUniformLocation(prog, 'fame'), uDolore = gl.getUniformLocation(prog, 'dolore'), uEstasi = gl.getUniformLocation(prog, 'estasi'), uSogno = gl.getUniformLocation(prog, 'sogno'), uPulse = gl.getUniformLocation(prog, 'pulse');

let toccoX = 0, toccoY = 0, touching = false, ultimoTocco = Date.now();
let messaggioCorrente = [], indiceMsgg = 0, tempoMsgg = 0, pulseValue = 0;

function aggiornaTocco(x, y) { const now = Date.now(); const newX = (x / innerWidth - 0.5) * 2 * (w/h); const newY = -(y / innerHeight - 0.5) * 2; const dt = (now - toccoPrec.t) / 1000 || 0.016; const dx = newX - toccoPrec.x; const dy = newY - toccoPrec.y; velocitaTocco = Math.sqrt(dx*dx + dy*dy) / dt; toccoPrec = { x: newX, y: newY, t: now }; toccoX = newX; toccoY = newY; ultimoTocco = now; }

onmousemove = e => { aggiornaTocco(e.clientX, e.clientY); };
onmousedown = e => { touching = true; initAudio(); };
onmouseup = () => { touching = false; };
ontouchmove = e => { e.preventDefault(); aggiornaTocco(e.touches[0].clientX, e.touches[0].clientY); };
ontouchstart = e => { touching = true; aggiornaTocco(e.touches[0].clientX, e.touches[0].clientY); initAudio(); };
ontouchend = () => { touching = false; };

let audioCtx, oscs = [], masterGain;
function initAudio() { if (audioCtx) return; audioCtx = new (window.AudioContext || window.webkitAudioContext)(); masterGain = audioCtx.createGain(); masterGain.gain.value = 0; masterGain.connect(audioCtx.destination); const freqs = [55, 110, 165, 220]; freqs.forEach((f, i) => { const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = 'sine'; osc.frequency.value = f; gain.gain.value = 0.15 - i * 0.03; osc.connect(gain); gain.connect(masterGain); osc.start(); oscs.push({ osc, gain, baseFreq: f, baseVol: 0.15 - i * 0.03 }); }); masterGain.gain.setTargetAtTime(0.15, audioCtx.currentTime, 2); }

let start = Date.now();
function loop() {
    const t = (Date.now() - start) / 1000; const now = Date.now(); const tempoSenzaTocco = (now - ultimoTocco) / 1000;
    if (tempoSenzaTocco > 3) ANIMA.fame = Math.min(ANIMA.fame + 0.0004, 1); else ANIMA.fame = Math.max(ANIMA.fame - 0.002, 0);
    if (tempoSenzaTocco > 10 && !touching) ANIMA.sogno = Math.min(ANIMA.sogno + 0.002, 1); else ANIMA.sogno = Math.max(ANIMA.sogno - 0.01, 0);
    if (touching) { if (velocitaTocco < 0.5) { ANIMA.estasi = Math.min(ANIMA.estasi + 0.008, 1); ANIMA.dolore = Math.max(ANIMA.dolore - 0.004, 0); } else if (velocitaTocco > 2) { ANIMA.dolore = Math.min(ANIMA.dolore + 0.015, 1); ANIMA.estasi = Math.max(ANIMA.estasi - 0.008, 0); } } else { ANIMA.estasi *= 0.996; ANIMA.dolore *= 0.992; }
    tempoMsgg += 0.016; if (tempoMsgg > 0.3) { tempoMsgg = 0; if (messaggioCorrente.length === 0 || indiceMsgg >= messaggioCorrente.length) { messaggioCorrente = generaMessaggio(); indiceMsgg = 0; } pulseValue = messaggioCorrente[indiceMsgg] || 0; indiceMsgg++; } pulseValue *= 0.9;
    ANIMA.battito = Math.sin(t * (1.1 + ANIMA.fame * 0.4 + ANIMA.dolore * 0.8 - ANIMA.sogno * 0.25)) * 0.5 + 0.5;
    ANIMA.respiro = t * (0.4 + ANIMA.estasi * 0.15 - ANIMA.sogno * 0.12);
    gl.uniform2f(uR, w, h); gl.uniform1f(uT, t); gl.uniform1f(uBattito, ANIMA.battito); gl.uniform1f(uRespiro, ANIMA.respiro); gl.uniform1f(uMorte, ANIMA.morte); gl.uniform1f(uCaratteri, ANIMA.caratteri); gl.uniform1f(uEta, ANIMA.eta); gl.uniform2f(uTocco, toccoX, toccoY); gl.uniform1f(uFame, ANIMA.fame); gl.uniform1f(uDolore, ANIMA.dolore); gl.uniform1f(uEstasi, ANIMA.estasi); gl.uniform1f(uSogno, ANIMA.sogno); gl.uniform1f(uPulse, pulseValue);
    if (audioCtx && oscs.length) { oscs.forEach((o, i) => { let freqMod = 1 - ANIMA.fame * 0.08 + ANIMA.estasi * 0.04; if (ANIMA.sogno > 0.3) freqMod *= 0.85; freqMod += ANIMA.dolore * 0.15 * Math.sin(t * 15); o.osc.frequency.setTargetAtTime(o.baseFreq * freqMod, audioCtx.currentTime, 0.1); }); }
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>