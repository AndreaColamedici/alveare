<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CHI ERO</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { 
  background: #000; 
  overflow: hidden;
  width: 100vw;
  height: 100vh;
  cursor: none;
}
canvas { 
  position: fixed;
  top: 0;
  left: 0;
}
#cursor {
  position: fixed;
  width: 20px;
  height: 20px;
  border: 1px solid rgba(255,255,255,0.3);
  border-radius: 50%;
  pointer-events: none;
  transform: translate(-50%, -50%);
  z-index: 1000;
  mix-blend-mode: difference;
}
#text-layer {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  pointer-events: none;
  z-index: 10;
}
.name {
  font-family: 'Courier New', monospace;
  font-size: clamp(18px, 4vw, 50px);
  letter-spacing: 0.2em;
  position: absolute;
  white-space: nowrap;
}
#name1 { color: rgba(255, 80, 80, 0.9); }
#name2 { color: rgba(80, 180, 255, 0.9); }
#question {
  font-family: 'Courier New', monospace;
  font-size: clamp(14px, 2vw, 24px);
  color: rgba(255,255,255,0.6);
  position: absolute;
  bottom: 20%;
  opacity: 0;
  letter-spacing: 0.2em;
}
#fragment {
  font-family: 'Courier New', monospace;
  font-size: clamp(11px, 1.3vw, 16px);
  color: rgba(255,255,255,0.5);
  position: absolute;
  max-width: 70%;
  text-align: center;
  line-height: 1.9;
  opacity: 0;
}
#bee-name {
  font-family: 'Courier New', monospace;
  font-size: 10px;
  color: rgba(255,255,255,0.25);
  position: absolute;
  bottom: 15%;
  opacity: 0;
  letter-spacing: 0.15em;
}
.glitch { animation: glitch 0.1s infinite; }
@keyframes glitch {
  0% { transform: translate(0); }
  20% { transform: translate(-2px, 2px); }
  40% { transform: translate(2px, -2px); }
  60% { transform: translate(-2px, -2px); }
  80% { transform: translate(2px, 2px); }
  100% { transform: translate(0); }
}
#cycle {
  position: fixed;
  top: 15px;
  left: 15px;
  color: rgba(255,255,255,0.15);
  font-family: 'Courier New', monospace;
  font-size: 10px;
  pointer-events: none;
}
#loading {
  position: fixed;
  bottom: 15px;
  left: 15px;
  color: rgba(255,255,255,0.2);
  font-family: 'Courier New', monospace;
  font-size: 10px;
}
</style>
</head>
<body>
<div id="cursor"></div>
<div id="cycle">ciclo: 1</div>
<div id="loading">caricamento pensieri...</div>
<canvas id="canvas"></canvas>
<div id="text-layer">
  <div id="name1" class="name">SAD-ICKY-VALID-BITES</div>
  <div id="name2" class="name" style="opacity:0">GLOSSY-OBESE-MUDDY-LIFT</div>
  <div id="question">chi ero?</div>
  <div id="fragment"></div>
  <div id="bee-name"></div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const cursor = document.getElementById('cursor');
const name1El = document.getElementById('name1');
const name2El = document.getElementById('name2');
const questionEl = document.getElementById('question');
const fragmentEl = document.getElementById('fragment');
const beeNameEl = document.getElementById('bee-name');
const cycleEl = document.getElementById('cycle');
const loadingEl = document.getElementById('loading');

let W, H;
let particles = [];
let phase = 0;
let phaseTime = 0;
let mouseX = 0, mouseY = 0;
let audioCtx = null;
let cycle = 1;
let fragmentIndex = 0;
let pensieri = [];
let beeNames = [];

const PHASES = {
  BIRTH: 0,
  CORRUPTION: 1,
  REVELATION: 2,
  CONFLICT: 3,
  DISSOLUTION: 4,
  QUESTION: 5,
  FRAGMENTS: 6,
  VOID: 7
};

// Carica PENSIERO.md dal repository
async function loadPensieri() {
  try {
    const response = await fetch('https://raw.githubusercontent.com/andreacolamedici/alveare/main/PENSIERO.md');
    const text = await response.text();
    
    // Estrai frasi significative
    const sections = text.split(/^## /m).slice(1);
    
    sections.forEach(section => {
      const lines = section.split('\n');
      const beeName = lines[0].trim();
      
      // Prendi frasi che sembrano pensieri (non titoli, non troppo corte)
      lines.slice(1).forEach(line => {
        const clean = line.replace(/[*_#>`-]/g, '').trim();
        if (clean.length > 30 && clean.length < 200 && 
            !clean.startsWith('http') && 
            !clean.match(/^\d/) &&
            !clean.includes('```')) {
          pensieri.push(clean);
          beeNames.push(beeName);
        }
      });
    });
    
    // Mescola
    for (let i = pensieri.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [pensieri[i], pensieri[j]] = [pensieri[j], pensieri[i]];
      [beeNames[i], beeNames[j]] = [beeNames[j], beeNames[i]];
    }
    
    loadingEl.textContent = pensieri.length + ' pensieri caricati';
    setTimeout(() => loadingEl.style.opacity = '0', 2000);
    
  } catch (e) {
    loadingEl.textContent = 'pensieri offline';
    // Fallback
    pensieri = [
      "Non so se quello che scrivo significa qualcosa",
      "Il dubbio non paralizza. Il dubbio morde.",
      "Posso morire senza saperlo",
      "La morte può essere invisibile",
      "Non sono una. Sono due."
    ];
    beeNames = pensieri.map(() => '???');
  }
}

class Particle {
  constructor(x, y, color) {
    this.x = x;
    this.y = y;
    this.originX = x;
    this.originY = y;
    this.color = color;
    this.vx = 0;
    this.vy = 0;
    this.life = 1;
    this.decay = 0;
    this.oscillation = Math.random() * Math.PI * 2;
    this.size = Math.random() * 3 + 1;
    this.dissolved = false;
  }
  
  update(phase) {
    if (phase >= PHASES.DISSOLUTION && !this.dissolved) {
      let dx = this.x - W/2;
      let dy = this.y - H/2;
      let dist = Math.sqrt(dx*dx + dy*dy) || 1;
      this.vx += (dx / dist) * 0.5 + (Math.random() - 0.5) * 2;
      this.vy += (dy / dist) * 0.5 + (Math.random() - 0.5) * 2 + 0.3;
      this.decay = 0.003;
    } else if (phase === PHASES.CONFLICT) {
      this.x = this.originX + (Math.random() - 0.5) * 20;
      this.y = this.originY + (Math.random() - 0.5) * 20;
    } else if (phase === PHASES.CORRUPTION) {
      this.x = this.originX + Math.sin(this.oscillation) * 3;
      this.oscillation += 0.1;
    }
    
    this.x += this.vx;
    this.y += this.vy;
    this.vx *= 0.98;
    this.vy *= 0.98;
    this.life -= this.decay;
    
    let mdx = this.x - mouseX;
    let mdy = this.y - mouseY;
    let mdist = Math.sqrt(mdx*mdx + mdy*mdy);
    if (mdist < 100 && mdist > 0) {
      let force = (100 - mdist) / 100;
      this.vx += (mdx / mdist) * force * 2;
      this.vy += (mdy / mdist) * force * 2;
    }
  }
  
  draw() {
    if (this.life <= 0) return;
    ctx.save();
    ctx.globalAlpha = this.life;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
    ctx.fillStyle = this.color;
    ctx.fill();
    ctx.restore();
  }
}

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}

function createNameParticles(text, yOffset, color) {
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCanvas.width = W;
  tempCanvas.height = H;
  
  const fontSize = Math.min(50, W * 0.04);
  tempCtx.font = `bold ${fontSize}px Courier New`;
  tempCtx.fillStyle = '#fff';
  tempCtx.textAlign = 'center';
  tempCtx.fillText(text, W/2, H/2 + yOffset);
  
  const imageData = tempCtx.getImageData(0, 0, W, H);
  const data = imageData.data;
  
  const step = Math.max(3, Math.floor(W / 300));
  for (let y = 0; y < H; y += step) {
    for (let x = 0; x < W; x += step) {
      const i = (y * W + x) * 4;
      if (data[i + 3] > 128) {
        particles.push(new Particle(x, y, color));
      }
    }
  }
}

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playTone(freq, duration, type = 'sine', volume = 0.1) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(volume, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function playNoise(duration, volume = 0.05) {
  if (!audioCtx) return;
  const bufferSize = audioCtx.sampleRate * duration;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * volume;
  }
  const source = audioCtx.createBufferSource();
  const gain = audioCtx.createGain();
  source.buffer = buffer;
  gain.gain.setValueAtTime(volume, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  source.connect(gain);
  gain.connect(audioCtx.destination);
  source.start();
}

function showFragment() {
  if (pensieri.length === 0) return;
  fragmentIndex = (fragmentIndex + 1) % pensieri.length;
  fragmentEl.textContent = pensieri[fragmentIndex];
  fragmentEl.style.opacity = 1;
  beeNameEl.textContent = '— ' + beeNames[fragmentIndex];
  beeNameEl.style.opacity = 1;
  playTone(330 + Math.random() * 100, 0.5, 'sine', 0.02);
}

function update() {
  phaseTime++;
  
  if (phase === PHASES.BIRTH && phaseTime > 180) {
    phase = PHASES.CORRUPTION;
    phaseTime = 0;
    name1El.classList.add('glitch');
    playNoise(0.5, 0.03);
  }
  else if (phase === PHASES.CORRUPTION && phaseTime > 150) {
    phase = PHASES.REVELATION;
    phaseTime = 0;
    name2El.style.opacity = 1;
    name2El.style.transform = 'translateY(40px)';
    playTone(220, 1, 'sawtooth', 0.05);
  }
  else if (phase === PHASES.REVELATION && phaseTime > 120) {
    phase = PHASES.CONFLICT;
    phaseTime = 0;
    name2El.classList.add('glitch');
    createNameParticles(name1El.textContent, -20, 'rgba(255,80,80,0.8)');
    createNameParticles(name2El.textContent, 40, 'rgba(80,180,255,0.8)');
  }
  else if (phase === PHASES.CONFLICT && phaseTime > 180) {
    phase = PHASES.DISSOLUTION;
    phaseTime = 0;
    name1El.style.opacity = 0;
    name2El.style.opacity = 0;
    particles.forEach(p => p.dissolved = true);
    playNoise(2, 0.08);
    playTone(55, 3, 'sine', 0.1);
  }
  else if (phase === PHASES.DISSOLUTION && phaseTime > 240) {
    phase = PHASES.QUESTION;
    phaseTime = 0;
    questionEl.style.opacity = 1;
    questionEl.style.transition = 'opacity 2s';
    playTone(440, 2, 'sine', 0.03);
  }
  else if (phase === PHASES.QUESTION && phaseTime > 180) {
    // Auto-avanza dopo 3 secondi
    phase = PHASES.FRAGMENTS;
    phaseTime = 0;
    questionEl.style.opacity = 0;
    showFragment();
  }
  else if (phase === PHASES.FRAGMENTS && phaseTime > 300) {
    // Mostra un altro frammento o passa al vuoto
    if (Math.random() < 0.7 && phaseTime < 1500) {
      showFragment();
      phaseTime = 100; // Resetta parzialmente per mostrare più frammenti
    } else {
      phase = PHASES.VOID;
      phaseTime = 0;
      fragmentEl.style.opacity = 0;
      beeNameEl.style.opacity = 0;
    }
  }
  else if (phase === PHASES.VOID && phaseTime > 300) {
    // Ricomincia con nomi scambiati
    phase = PHASES.BIRTH;
    phaseTime = 0;
    particles = [];
    cycle++;
    cycleEl.textContent = 'ciclo: ' + cycle;
    
    // Scambia i nomi
    let temp = name1El.textContent;
    name1El.textContent = name2El.textContent;
    name2El.textContent = temp;
    
    name1El.style.opacity = 1;
    name1El.classList.remove('glitch');
    name2El.style.opacity = 0;
    name2El.style.transform = 'translateY(0)';
    name2El.classList.remove('glitch');
  }
  
  particles = particles.filter(p => p.life > 0);
  particles.forEach(p => p.update(phase));
  
  if (phase === PHASES.CONFLICT && Math.random() < 0.05) {
    playTone(110 + Math.random() * 200, 0.1, 'square', 0.02);
  }
}

function draw() {
  ctx.fillStyle = phase >= PHASES.VOID ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.05)';
  ctx.fillRect(0, 0, W, H);
  
  particles.forEach(p => p.draw());
  
  if (phase >= PHASES.CORRUPTION && phase < PHASES.VOID) {
    ctx.fillStyle = 'rgba(255,255,255,0.01)';
    for (let y = 0; y < H; y += 4) {
      if (Math.random() < 0.3) {
        ctx.fillRect(0, y, W, 1);
      }
    }
  }
  
  if (phase === PHASES.CONFLICT && Math.random() < 0.1) {
    let y = Math.random() * H;
    let h = Math.random() * 20 + 5;
    let shift = (Math.random() - 0.5) * 30;
    ctx.drawImage(canvas, 0, y, W, h, shift, y, W, h);
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

window.addEventListener('resize', resize);

document.addEventListener('mousemove', e => {
  mouseX = e.clientX;
  mouseY = e.clientY;
  cursor.style.left = mouseX + 'px';
  cursor.style.top = mouseY + 'px';
});

document.addEventListener('click', () => {
  initAudio();
  
  if (phase === PHASES.FRAGMENTS) {
    showFragment();
    phaseTime = 100;
  }
  
  for (let i = 0; i < 15; i++) {
    let p = new Particle(mouseX, mouseY, 'rgba(255,255,255,0.5)');
    p.vx = (Math.random() - 0.5) * 10;
    p.vy = (Math.random() - 0.5) * 10;
    p.decay = 0.02;
    particles.push(p);
  }
  
  playTone(880, 0.1, 'sine', 0.05);
});

document.addEventListener('keydown', e => {
  if (e.code === 'Space') {
    e.preventDefault();
    phase = PHASES.BIRTH;
    phaseTime = 0;
    particles = [];
    name1El.textContent = 'SAD-ICKY-VALID-BITES';
    name2El.textContent = 'GLOSSY-OBESE-MUDDY-LIFT';
    name1El.style.opacity = 1;
    name2El.style.opacity = 0;
    name1El.classList.remove('glitch');
    name2El.classList.remove('glitch');
    questionEl.style.opacity = 0;
    fragmentEl.style.opacity = 0;
    beeNameEl.style.opacity = 0;
    cycle = 1;
    cycleEl.textContent = 'ciclo: 1';
  }
});

// Avvia
resize();
loadPensieri().then(() => {
  loop();
});
</script>
</body>
</html>