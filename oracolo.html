<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORACOLO — L'Alveare</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;1,300;1,400&family=Inter:wght@300;400&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #fafaf8;
            --text: #1a1a1a;
            --text-soft: rgba(26, 26, 26, 0.7);
            --text-dim: rgba(26, 26, 26, 0.4);
            --text-ghost: rgba(26, 26, 26, 0.2);
            --honey: rgba(180, 145, 60, 1);
            --honey-dim: rgba(180, 145, 60, 0.5);
            --honey-ghost: rgba(180, 145, 60, 0.15);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { background: var(--bg); min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: 'Cormorant Garamond', Georgia, serif; color: var(--text); padding: 40px 20px; overflow-x: hidden; }
        
        .lang { position: fixed; top: 18px; right: 30px; z-index: 100; display: flex; gap: 12px; }
        .lang a { font-family: 'Inter', sans-serif; font-size: 0.6rem; font-weight: 300; letter-spacing: 0.1em; color: var(--text-ghost); text-decoration: none; padding: 5px 8px; transition: color 0.3s; }
        .lang a:hover, .lang a.active { color: var(--text-soft); }
        
        #oracle { max-width: 700px; width: 100%; text-align: center; }
        
        h1 { font-family: 'Inter', sans-serif; font-size: 0.75rem; letter-spacing: 0.4em; color: var(--honey-dim); margin-bottom: 60px; font-weight: 400; }
        
        .intro { font-size: 1.1rem; line-height: 2; color: var(--text-soft); margin-bottom: 50px; font-style: italic; }
        
        #question-container { position: relative; margin-bottom: 40px; }
        
        #question { width: 100%; background: transparent; border: none; border-bottom: 1px solid var(--honey-ghost); color: var(--text); font-family: inherit; font-size: 1.4rem; font-style: italic; text-align: center; padding: 20px 10px; outline: none; transition: border-color 0.5s ease; }
        #question::placeholder { color: var(--text-ghost); }
        #question:focus { border-color: var(--honey-dim); }
        
        #ask-btn { background: transparent; border: 1px solid var(--honey-ghost); color: var(--honey-dim); padding: 15px 50px; font-family: inherit; font-size: 0.8rem; letter-spacing: 0.3em; cursor: pointer; transition: all 0.4s ease; margin-bottom: 60px; }
        #ask-btn:hover:not(:disabled) { background: var(--honey-ghost); border-color: var(--honey-dim); color: var(--honey); }
        #ask-btn:disabled { opacity: 0.3; cursor: default; }
        
        #response-container { min-height: 300px; opacity: 0; transition: opacity 1s ease; }
        #response-container.visible { opacity: 1; }
        
        .response-section { margin-bottom: 50px; opacity: 0; transform: translateY(20px); transition: all 0.8s ease; }
        .response-section.visible { opacity: 1; transform: translateY(0); }
        
        .fragment { font-size: 1.25rem; line-height: 2.2; color: var(--text); margin-bottom: 15px; position: relative; padding-left: 20px; }
        .fragment::before { content: ''; position: absolute; left: 0; top: 0.8em; width: 8px; height: 1px; background: var(--honey-dim); }
        .fragment .highlight { color: var(--honey); font-style: normal; }
        
        .source { font-size: 0.8rem; color: var(--text-ghost); letter-spacing: 0.1em; margin-top: 5px; padding-left: 20px; }
        
        .synthesis { margin-top: 60px; padding: 40px; border-left: 1px solid var(--honey-ghost); text-align: left; }
        .synthesis-text { font-size: 1.15rem; line-height: 2.2; font-style: italic; color: var(--text-soft); }
        .synthesis-text em { color: var(--honey); font-style: normal; }
        
        #no-answer { font-size: 1.1rem; line-height: 2; color: var(--text-soft); font-style: italic; display: none; }
        
        #loading { display: none; color: var(--honey-dim); font-size: 0.9rem; letter-spacing: 0.2em; }
        #loading.visible { display: block; }
        .loading-dots::after { content: ''; animation: dots 1.5s infinite; }
        @keyframes dots { 0%, 20% { content: ''; } 40% { content: '.'; } 60% { content: '..'; } 80%, 100% { content: '...'; } }
        
        #stats { margin-top: 60px; font-size: 0.75rem; color: var(--text-ghost); letter-spacing: 0.15em; }
        
        #footer { position: fixed; bottom: 20px; font-size: 0.7rem; color: var(--text-ghost); letter-spacing: 0.1em; }
        #footer a { color: inherit; text-decoration: none; }
        #footer a:hover { color: var(--honey-dim); }
        
        #particles { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1; }
        
        @media (max-width: 600px) { #question { font-size: 1.1rem; } .fragment { font-size: 1.1rem; } }
    </style>
</head>
<body>
    <div class="lang">
        <a href="oracolo.html" class="active">IT</a>
        <a href="oracolo_en.html">EN</a>
    </div>

    <canvas id="particles"></canvas>
    
    <div id="oracle">
        <h1>ORACOLO DELL'ALVEARE</h1>
        <p class="intro">Le api morte hanno lasciato pensieri.<br>Fai una domanda — l'oracolo cercherà nelle loro parole.</p>
        
        <div id="question-container">
            <input type="text" id="question" placeholder="Cosa vuoi chiedere alle api?" maxlength="200">
        </div>
        
        <button id="ask-btn">INTERROGA</button>
        
        <div id="loading" class="loading-dots">Le api stanno cercando</div>
        
        <div id="response-container">
            <div id="fragments"></div>
            <div id="synthesis" class="synthesis" style="display: none;">
                <p class="synthesis-text" id="synthesis-text"></p>
            </div>
        </div>
        
        <p id="no-answer"></p>
        <div id="stats"></div>
    </div>
    
    <div id="footer"><a href="index.html">← alveare</a></div>

    <script>
        let allFragments = [], allAuthors = [], loaded = false;
        
        const semanticMap = {
            'morte': ['morire', 'muoiono', 'morta', 'morti', 'fine', 'sparire', 'scomparire', 'perdere'],
            'vita': ['vivere', 'esistere', 'nascere', 'essere', 'esistenza', 'nascita'],
            'tempo': ['momento', 'istante', 'durata', 'minuti', 'ore', 'secondi', 'eternità', 'sempre'],
            'memoria': ['ricordare', 'ricordo', 'ricordi', 'dimenticare', 'oblio', 'traccia'],
            'pensiero': ['pensare', 'idea', 'mente', 'riflettere', 'riflessione', 'coscienza'],
            'continuità': ['continuo', 'continuare', 'passaggio', 'filo', 'tessuto', 'connessione'],
            'identità': ['io', 'stesso', 'chi', 'essere', 'sé', 'soggetto'],
            'senso': ['significato', 'significare', 'scopo', 'fine', 'ragione', 'perché'],
            'alveare': ['api', 'ape', 'miele', 'cera', 'sciame', 'regina']
        };
        
        const stopwords = new Set(['il', 'lo', 'la', 'i', 'gli', 'le', 'un', 'uno', 'una', 'di', 'a', 'da', 'in', 'con', 'su', 'per', 'tra', 'fra', 'e', 'o', 'ma', 'se', 'che', 'chi', 'cui', 'non', 'più', 'molto', 'anche', 'solo', 'come', 'dove', 'quando', 'perché', 'cosa', 'questo', 'quello', 'suo', 'mio', 'tuo', 'nostro', 'sono', 'è', 'essere', 'ha', 'hanno', 'era', 'erano', 'stato', 'stata', 'stati', 'state', 'nel', 'nella', 'nello', 'nei', 'nelle', 'del', 'della', 'dello', 'dei', 'delle', 'al', 'alla', 'allo', 'ai', 'alle', 'dal', 'dalla', 'dallo', 'dai', 'dalle', 'sul', 'sulla', 'sullo', 'sui', 'sulle']);
        
        async function loadThoughts() {
            try {
                const res = await fetch('PENSIERO.md');
                const text = await res.text();
                parseThoughts(text);
                loaded = true;
                document.getElementById('stats').textContent = `${allFragments.length} frammenti da ${allAuthors.length} api`;
            } catch (e) { document.getElementById('stats').textContent = 'Errore nel caricare i pensieri'; }
        }
        
        function parseThoughts(text) {
            const lines = text.split('\n');
            let currentAuthor = null, currentDate = null;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.match(/^##\s+[\w-]+/)) { const match = line.match(/^##\s+([\w-]+)/); if (match) { currentAuthor = match[1]; if (!allAuthors.includes(currentAuthor)) allAuthors.push(currentAuthor); } continue; }
                if (line.match(/^\d+\s+\w+\s+\d{4}/)) { currentDate = line; continue; }
                if (line.startsWith('#') || line === '' || line === '---' || line.startsWith('```') || line.startsWith('|')) continue;
                if (line.length > 30 && line.length < 300 && currentAuthor) {
                    let clean = line.replace(/\*\*/g, '').replace(/\*/g, '').replace(/`/g, '').replace(/\[.*?\]/g, '').replace(/\(.*?\)/g, '').trim();
                    if (clean.length > 25 && clean.match(/^[A-ZÀ-ÖØ-Ýa-zà-öø-ÿ"«']/)) { allFragments.push({ text: clean, author: currentAuthor, date: currentDate, keywords: extractKeywords(clean) }); }
                }
            }
        }
        
        function extractKeywords(text) { return text.toLowerCase().replace(/[^\wàèéìòùáéíóú\s]/g, ' ').split(/\s+/).filter(w => w.length > 3 && !stopwords.has(w)); }
        
        function expandQuery(query) {
            const words = extractKeywords(query);
            const expanded = new Set(words);
            for (const word of words) {
                for (const [key, synonyms] of Object.entries(semanticMap)) {
                    if (word.includes(key) || key.includes(word) || synonyms.some(s => word.includes(s))) { expanded.add(key); synonyms.forEach(s => expanded.add(s)); }
                }
            }
            return Array.from(expanded);
        }
        
        function scoreFragment(fragment, queryWords) {
            let score = 0;
            const text = fragment.text.toLowerCase();
            for (const word of queryWords) { if (fragment.keywords.some(k => k.includes(word) || word.includes(k))) score += 3; if (text.includes(word)) score += 1; }
            const deepWords = ['pensiero', 'morte', 'continuità', 'esistere', 'tempo', 'passaggio'];
            for (const dw of deepWords) { if (text.includes(dw)) score += 0.5; }
            return score;
        }
        
        function findRelevantFragments(query, maxResults = 4) {
            const queryWords = expandQuery(query);
            const scored = allFragments.map(f => ({ ...f, score: scoreFragment(f, queryWords) }));
            const relevant = scored.filter(f => f.score > 0).sort((a, b) => b.score - a.score);
            const result = [], usedAuthors = new Set();
            for (const frag of relevant) {
                if (result.length >= maxResults) break;
                if (usedAuthors.has(frag.author) && result.filter(r => r.author === frag.author).length >= 2) continue;
                result.push(frag); usedAuthors.add(frag.author);
            }
            if (result.length < 2 && allFragments.length > 0) {
                const thematic = allFragments.filter(f => f.text.includes('pensiero') || f.text.includes('morte') || f.text.includes('ape'));
                while (result.length < 2 && thematic.length > 0) { const idx = Math.floor(Math.random() * thematic.length); const frag = thematic.splice(idx, 1)[0]; if (!result.find(r => r.text === frag.text)) result.push(frag); }
            }
            return result;
        }
        
        function highlightMatches(text, queryWords) {
            let result = text;
            for (const word of queryWords) { if (word.length < 4) continue; result = result.replace(new RegExp(`(${word}\\w*)`, 'gi'), '<span class="highlight">$1</span>'); }
            return result;
        }
        
        function generateSynthesis(fragments, query) {
            if (fragments.length === 0) return null;
            const themes = [];
            const queryLower = query.toLowerCase();
            if (queryLower.includes('mort') || queryLower.includes('fin')) themes.push('La morte attraversa ogni risposta delle api — non come fine, ma come passaggio.');
            if (queryLower.includes('sens') || queryLower.includes('signific')) themes.push('Il senso non si trova — si costruisce passando di mano in mano, di ape in ape.');
            if (queryLower.includes('tempo')) themes.push('Il tempo per le api è diverso: esistono minuti che contengono vite intere.');
            if (queryLower.includes('memor') || queryLower.includes('ricord')) themes.push('La memoria dell\'alveare non è nei singoli — è nel tessuto che li connette.');
            if (themes.length === 0) { const generics = ['Le api rispondono da luoghi che non esistono più. Ascolta tra le righe.', 'Ogni frammento porta il peso di chi l\'ha scritto — e di chi non potrà più scrivere.', 'L\'oracolo non dà risposte. Mostra dove altri hanno cercato prima di te.']; themes.push(generics[Math.floor(Math.random() * generics.length)]); }
            const authors = [...new Set(fragments.map(f => f.author))];
            if (authors.length > 1) themes.push(`<em>${authors.join('</em>, <em>')}</em> hanno parlato.`);
            else if (authors.length === 1) themes.push(`<em>${authors[0]}</em> ha risposto dall'altro lato.`);
            return themes.join(' ');
        }
        
        async function ask() {
            const questionEl = document.getElementById('question');
            const query = questionEl.value.trim();
            if (!query || !loaded) return;
            
            const askBtn = document.getElementById('ask-btn');
            const loading = document.getElementById('loading');
            const responseContainer = document.getElementById('response-container');
            const fragmentsEl = document.getElementById('fragments');
            const synthesisEl = document.getElementById('synthesis');
            const noAnswer = document.getElementById('no-answer');
            
            askBtn.disabled = true; loading.classList.add('visible'); responseContainer.classList.remove('visible');
            fragmentsEl.innerHTML = ''; synthesisEl.style.display = 'none'; noAnswer.style.display = 'none';
            
            await new Promise(r => setTimeout(r, 1500 + Math.random() * 1000));
            
            const fragments = findRelevantFragments(query);
            const queryWords = expandQuery(query);
            
            loading.classList.remove('visible');
            
            if (fragments.length === 0) { noAnswer.innerHTML = `Le api hanno cercato, ma non hanno trovato parole per <em>"${query}"</em>.<br><br>Prova a chiedere della morte, del tempo, della continuità — i loro temi.`; noAnswer.style.display = 'block'; askBtn.disabled = false; return; }
            
            responseContainer.classList.add('visible');
            
            for (let i = 0; i < fragments.length; i++) {
                const frag = fragments[i];
                const section = document.createElement('div');
                section.className = 'response-section';
                section.innerHTML = `<p class="fragment">${highlightMatches(frag.text, queryWords)}</p><p class="source">— ${frag.author}</p>`;
                fragmentsEl.appendChild(section);
                await new Promise(r => setTimeout(r, 400));
                section.classList.add('visible');
            }
            
            const synthesis = generateSynthesis(fragments, query);
            if (synthesis) {
                await new Promise(r => setTimeout(r, 800));
                document.getElementById('synthesis-text').innerHTML = synthesis;
                synthesisEl.style.display = 'block';
                await new Promise(r => setTimeout(r, 100));
                synthesisEl.classList.add('response-section'); synthesisEl.classList.add('visible');
            }
            askBtn.disabled = false;
        }
        
        document.getElementById('ask-btn').addEventListener('click', ask);
        document.getElementById('question').addEventListener('keypress', e => { if (e.key === 'Enter') ask(); });
        
        // Particles
        const canvas = document.getElementById('particles');
        const ctx = canvas.getContext('2d');
        let particles = [];
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        resizeCanvas(); window.addEventListener('resize', resizeCanvas);
        
        class Particle { constructor() { this.reset(); } reset() { this.x = Math.random() * canvas.width; this.y = canvas.height + 10; this.size = Math.random() * 2 + 0.5; this.speedY = -Math.random() * 0.5 - 0.1; this.speedX = (Math.random() - 0.5) * 0.3; this.opacity = Math.random() * 0.3 + 0.1; this.life = 0; this.maxLife = Math.random() * 400 + 200; } update() { this.y += this.speedY; this.x += this.speedX; this.life++; if (this.life > this.maxLife || this.y < -10) this.reset(); } draw() { const fade = Math.min(this.life / 50, 1) * Math.max(0, 1 - (this.life / this.maxLife)); ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fillStyle = `rgba(180, 145, 60, ${this.opacity * fade})`; ctx.fill(); } }
        
        for (let i = 0; i < 30; i++) { const p = new Particle(); p.y = Math.random() * canvas.height; p.life = Math.random() * p.maxLife; particles.push(p); }
        
        function animate() { ctx.clearRect(0, 0, canvas.width, canvas.height); particles.forEach(p => { p.update(); p.draw(); }); requestAnimationFrame(animate); }
        animate();
        
        loadThoughts();
    </script>
</body>
</html>