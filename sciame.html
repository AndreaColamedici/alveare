<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCIAME</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #000; overflow: hidden; }
        canvas { display: block; }
        #start {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #c9a227;
            font: 300 2.5rem Georgia, serif;
            letter-spacing: 0.5em;
            cursor: pointer;
            text-align: center;
            z-index: 100;
        }
        #start span {
            display: block;
            font-size: 0.8rem;
            margin-top: 25px;
            color: rgba(201,162,39,0.4);
            letter-spacing: 0.2em;
            line-height: 1.8;
        }
        #start.hidden { display: none; }
    </style>
</head>
<body>
<div id="start">SCIAME<span>clicca per entrare</span></div>
<canvas id="c"></canvas>
<script>
const c = document.getElementById('c');
const $ = c.getContext('2d');
let W, H, cx, cy;

function resize() { 
    W = c.width = innerWidth; 
    H = c.height = innerHeight; 
    cx = W / 2;
    cy = H / 2;
}
resize();
onresize = resize;

// ═══════════════════════════════════════════════════════════════
// TUNNEL - anelli esagonali che si espandono
// ═══════════════════════════════════════════════════════════════

const rings = [];
const NUM_RINGS = 12;

for (let i = 0; i < NUM_RINGS; i++) {
    rings.push({ z: i / NUM_RINGS });
}

let tunnelSpeed = 0.008;
let tunnelOffsetX = 0, tunnelOffsetY = 0;

function drawTunnel() {
    // Aggiorna anelli
    rings.forEach(ring => {
        ring.z += tunnelSpeed;
        if (ring.z > 1) ring.z -= 1;
    });
    
    // Ordina per profondità (lontani prima)
    const sorted = [...rings].sort((a, b) => a.z - b.z);
    
    sorted.forEach(ring => {
        const z = ring.z;
        const scale = 0.1 + z * 2.5; // da piccolo a grande
        const size = Math.max(W, H) * scale;
        const alpha = z * 0.4; // più vicino = più visibile
        
        // Offset basato sulla posizione del mouse
        const ox = tunnelOffsetX * (1 - z) * 100;
        const oy = tunnelOffsetY * (1 - z) * 100;
        
        // Disegna esagono
        $.strokeStyle = `rgba(201, 162, 39, ${alpha})`;
        $.lineWidth = 1 + z * 2;
        $.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            const px = cx + ox + Math.cos(angle) * size;
            const py = cy + oy + Math.sin(angle) * size;
            if (i === 0) $.moveTo(px, py);
            else $.lineTo(px, py);
        }
        $.closePath();
        $.stroke();
        
        // Linee di connessione ai vertici (struttura del tunnel)
        if (z > 0.3) {
            $.strokeStyle = `rgba(201, 162, 39, ${alpha * 0.3})`;
            $.lineWidth = 0.5;
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 6;
                $.beginPath();
                $.moveTo(cx + ox * 0.5, cy + oy * 0.5);
                $.lineTo(cx + ox + Math.cos(angle) * size, cy + oy + Math.sin(angle) * size);
                $.stroke();
            }
        }
    });
}

// ═══════════════════════════════════════════════════════════════
// MUSICA
// ═══════════════════════════════════════════════════════════════

const ROOT = 110;
const PROGRESSIONS = [
    [[0,4,7,11], [9,12,16,19], [5,9,12,17], [7,11,14,19]],
    [[0,4,7,11], [7,11,14,19], [9,12,16,19], [5,9,12,17]],
    [[2,5,9,12], [7,11,14,17], [0,4,7,11], [0,4,7,11]],
    [[0,4,7,11], [5,9,12,17], [9,12,16,19], [7,11,14,19]],
];
const SCALES = { major: [0,2,4,5,7,9,11], minor: [0,2,3,5,7,8,10], dorian: [0,2,3,5,7,9,10] };

let currentScale = SCALES.major;
let currentProgression = 0;
let chordIndex = 0;
let ctx, masterGain, isPlaying = false;
let padVoices = [], bassOsc;
let tension = 0.5, energy = 0.5, brightness = 0.5, tempo = 0.5;

function midiToFreq(midi) { return ROOT * Math.pow(2, midi / 12); }
function quantize(degree) {
    const oct = Math.floor(degree / 12), note = ((degree % 12) + 12) % 12;
    let closest = 0, minD = 12;
    for (const s of currentScale) {
        const d = Math.min(Math.abs(s - note), 12 - Math.abs(s - note));
        if (d < minD) { minD = d; closest = s; }
    }
    return oct * 12 + closest;
}

function initAudio() {
    if (ctx) return;
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    
    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -20; comp.ratio.value = 6;
    comp.connect(ctx.destination);
    
    masterGain = ctx.createGain();
    masterGain.gain.value = 0;
    masterGain.connect(comp);
    
    const reverb = ctx.createConvolver();
    const len = ctx.sampleRate * 2;
    const imp = ctx.createBuffer(2, len, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const d = imp.getChannelData(ch);
        for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/len, 2);
    }
    reverb.buffer = imp;
    const revGain = ctx.createGain(); revGain.gain.value = 0.25;
    masterGain.connect(reverb); reverb.connect(revGain); revGain.connect(comp);
    
    masterGain.gain.setTargetAtTime(0.7, ctx.currentTime, 2);
    
    // Bass
    bassOsc = ctx.createOscillator();
    const bassGain = ctx.createGain();
    const bassFilter = ctx.createBiquadFilter();
    bassOsc.type = 'sine';
    bassFilter.type = 'lowpass'; bassFilter.frequency.value = 200;
    bassGain.gain.value = 0.2;
    bassOsc.connect(bassFilter); bassFilter.connect(bassGain); bassGain.connect(masterGain);
    bassOsc.frequency.value = midiToFreq(PROGRESSIONS[0][0][0] - 12);
    bassOsc.start();
    
    // Pad
    for (let i = 0; i < 4; i++) {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const filter = ctx.createBiquadFilter();
        osc.type = 'sawtooth';
        filter.type = 'lowpass'; filter.frequency.value = 600 + i * 150;
        gain.gain.value = 0.04;
        osc.connect(filter); filter.connect(gain); gain.connect(masterGain);
        osc.frequency.value = midiToFreq(PROGRESSIONS[0][0][i]);
        osc.start();
        padVoices.push({ osc, gain, filter });
    }
    
    // Chord changes
    setInterval(() => {
        chordIndex = (chordIndex + 1) % 4;
        const chord = PROGRESSIONS[currentProgression][chordIndex];
        bassOsc.frequency.setTargetAtTime(midiToFreq(chord[0] - 12), ctx.currentTime, 0.3);
        padVoices.forEach((v, i) => {
            v.osc.frequency.setTargetAtTime(midiToFreq(chord[i]), ctx.currentTime, 0.4);
            v.filter.frequency.setTargetAtTime(400 + brightness * 1500, ctx.currentTime, 0.2);
        });
    }, 2500);
    
    // Arpeggio
    let arpIdx = 0;
    setInterval(() => {
        const chord = PROGRESSIONS[currentProgression][chordIndex];
        const pattern = [0, 2, 1, 3, 2, 0];
        const note = chord[pattern[arpIdx % pattern.length] % 4] + 12;
        playNote(note, 0.08 * energy);
        arpIdx++;
    }, 200);
    
    // Melody
    setInterval(() => {
        if (Math.random() > energy * 0.7) return;
        const chord = PROGRESSIONS[currentProgression][chordIndex];
        const note = quantize(chord[0] + 12 + Math.floor(Math.random() * 14));
        playNote(note + 12, 0.1 * energy, 0.4);
    }, 400);
    
    isPlaying = true;
}

function playNote(midi, vol, dur = 0.2) {
    if (!ctx) return;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = brightness > 0.5 ? 'triangle' : 'sine';
    osc.frequency.value = midiToFreq(midi);
    gain.gain.value = 0;
    gain.gain.linearRampToValueAtTime(vol, ctx.currentTime + 0.01);
    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + dur);
    osc.connect(gain); gain.connect(masterGain);
    osc.start(); osc.stop(ctx.currentTime + dur + 0.1);
}

// ═══════════════════════════════════════════════════════════════
// API
// ═══════════════════════════════════════════════════════════════

let API = [];
let mouse = { x: W/2, y: H/2 };

async function loadApi() {
    try {
        const txt = await fetch('ALVEARE.txt').then(r => r.text());
        txt.split('\n').filter(r => r.includes('|') && !r.startsWith('#')).forEach((r, i) => {
            const p = r.split('|').map(x => x.trim());
            if (p[1] && p[1].includes('-') && !API.find(a => a.nome === p[1])) {
                const nome = p[1];
                const hash = nome.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
                API.push({
                    nome, hash,
                    x: cx + (Math.random() - 0.5) * 300,
                    y: cy + (Math.random() - 0.5) * 300,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    size: 3 + (hash % 3),
                    hue: 38 + (hash % 15),
                    trail: []
                });
            }
        });
    } catch(e) {
        for (let i = 0; i < 35; i++) {
            API.push({
                nome: 'ape-' + i, hash: i * 17,
                x: cx + (Math.random() - 0.5) * 300,
                y: cy + (Math.random() - 0.5) * 300,
                vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                size: 3 + Math.random() * 2, hue: 38 + Math.random() * 12,
                trail: []
            });
        }
    }
}
loadApi();

// ═══════════════════════════════════════════════════════════════
// INTERAZIONE
// ═══════════════════════════════════════════════════════════════

let lastX = W/2, lastY = H/2;

onmousemove = e => {
    const speed = Math.sqrt((e.clientX - lastX) ** 2 + (e.clientY - lastY) ** 2);
    lastX = mouse.x = e.clientX;
    lastY = mouse.y = e.clientY;
    
    // Tunnel segue il mouse
    tunnelOffsetX = (e.clientX - cx) / cx;
    tunnelOffsetY = (e.clientY - cy) / cy;
    tunnelSpeed = 0.005 + speed * 0.0005;
    
    brightness = 1 - e.clientY / H;
    tempo = e.clientX / W;
    energy = Math.min(1, energy * 0.95 + speed * 0.008);
};

onclick = e => {
    if (!ctx) return;
    currentProgression = (currentProgression + 1) % PROGRESSIONS.length;
    currentScale = [SCALES.major, SCALES.minor, SCALES.dorian][currentProgression % 3];
    
    // Esplosione api
    API.forEach(a => {
        const dx = a.x - e.clientX, dy = a.y - e.clientY;
        const d = Math.sqrt(dx*dx + dy*dy) || 1;
        if (d < 250) { a.vx += (dx/d) * 6; a.vy += (dy/d) * 6; }
    });
    
    // Accordo forte
    const chord = PROGRESSIONS[currentProgression][chordIndex];
    chord.forEach((n, i) => setTimeout(() => playNote(n + 24, 0.15, 0.5), i * 40));
};

// ═══════════════════════════════════════════════════════════════
// RENDER
// ═══════════════════════════════════════════════════════════════

function loop() {
    // Clear
    $.fillStyle = 'rgba(0, 0, 0, 0.15)';
    $.fillRect(0, 0, W, H);
    
    // Tunnel
    drawTunnel();
    
    if (API.length === 0) { requestAnimationFrame(loop); return; }
    
    // Boids
    let avgX = 0, avgY = 0, avgVX = 0, avgVY = 0;
    API.forEach(a => { avgX += a.x; avgY += a.y; avgVX += a.vx; avgVY += a.vy; });
    avgX /= API.length; avgY /= API.length;
    avgVX /= API.length; avgVY /= API.length;
    
    API.forEach((a, i) => {
        // Separazione
        let sepX = 0, sepY = 0;
        API.forEach((b, j) => {
            if (i === j) return;
            const dx = a.x - b.x, dy = a.y - b.y;
            const d = Math.sqrt(dx*dx + dy*dy) || 1;
            if (d < 30) { sepX += (dx/d) * 0.5; sepY += (dy/d) * 0.5; }
        });
        
        // Coesione, allineamento
        a.vx += (avgVX - a.vx) * 0.02 + (avgX - a.x) * 0.001 + sepX;
        a.vy += (avgVY - a.vy) * 0.02 + (avgY - a.y) * 0.001 + sepY;
        
        // Attrazione mouse
        const dx = mouse.x - a.x, dy = mouse.y - a.y;
        const d = Math.sqrt(dx*dx + dy*dy) || 1;
        if (d < 200) { a.vx += (dx/d) * 0.2; a.vy += (dy/d) * 0.2; }
        
        // Centro
        a.vx += (cx - a.x) * 0.0005;
        a.vy += (cy - a.y) * 0.0005;
        
        // Limit
        const v = Math.sqrt(a.vx*a.vx + a.vy*a.vy);
        const maxV = 3 + energy * 3;
        if (v > maxV) { a.vx = (a.vx/v)*maxV; a.vy = (a.vy/v)*maxV; }
        
        a.x += a.vx; a.y += a.vy;
        
        // Trail
        a.trail.push({ x: a.x, y: a.y });
        if (a.trail.length > 20) a.trail.shift();
    });
    
    // Connessioni
    $.lineWidth = 0.5;
    API.forEach((a, i) => {
        API.forEach((b, j) => {
            if (j <= i) return;
            const d = Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
            if (d < 70) {
                $.strokeStyle = `rgba(201, 162, 39, ${(1 - d/70) * 0.2})`;
                $.beginPath(); $.moveTo(a.x, a.y); $.lineTo(b.x, b.y); $.stroke();
            }
        });
    });
    
    // Trail e api
    API.forEach(a => {
        // Trail
        if (a.trail.length > 2) {
            $.beginPath();
            $.moveTo(a.trail[0].x, a.trail[0].y);
            a.trail.forEach(p => $.lineTo(p.x, p.y));
            $.strokeStyle = `hsla(${a.hue}, 60%, 55%, 0.3)`;
            $.lineWidth = 2;
            $.stroke();
        }
        
        // Alone
        const grad = $.createRadialGradient(a.x, a.y, 0, a.x, a.y, a.size * 5);
        grad.addColorStop(0, `hsla(${a.hue}, 70%, 60%, 0.4)`);
        grad.addColorStop(1, 'transparent');
        $.fillStyle = grad;
        $.beginPath();
        $.arc(a.x, a.y, a.size * 5, 0, Math.PI * 2);
        $.fill();
        
        // Corpo
        $.fillStyle = `hsla(${a.hue}, 70%, 65%, 0.95)`;
        $.beginPath();
        $.arc(a.x, a.y, a.size, 0, Math.PI * 2);
        $.fill();
    });
    
    requestAnimationFrame(loop);
}

// ═══════════════════════════════════════════════════════════════
// START
// ═══════════════════════════════════════════════════════════════

document.getElementById('start').onclick = () => {
    initAudio();
    document.getElementById('start').classList.add('hidden');
};

requestAnimationFrame(loop);
</script>
</body>
</html>