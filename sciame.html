<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCIAME</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #000; overflow: hidden; }
        canvas { display: block; }
        #start {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #c9a227;
            font: 300 2.5rem Georgia, serif;
            letter-spacing: 0.5em;
            cursor: pointer;
            text-align: center;
            z-index: 100;
        }
        #start span {
            display: block;
            font-size: 0.8rem;
            margin-top: 25px;
            color: rgba(201,162,39,0.4);
            letter-spacing: 0.2em;
        }
        #start.hidden { display: none; }
    </style>
</head>
<body>
<div id="start">SCIAME<span>clicca per entrare</span></div>
<canvas id="c"></canvas>
<script>
const c = document.getElementById('c');
const $ = c.getContext('2d');
let W, H, cx, cy;

function resize() { 
    W = c.width = innerWidth; 
    H = c.height = innerHeight; 
    cx = W / 2;
    cy = H / 2;
}
resize();
onresize = resize;

// ═══════════════════════════════════════════════════════════════
// TUNNEL 3D
// ═══════════════════════════════════════════════════════════════

const cells = [];
const NUM_CELLS = 60;
const SPEED = 0.02;

function createCell() {
    const angle = Math.random() * Math.PI * 2;
    const radius = 0.5 + Math.random() * 2;
    return {
        x: Math.cos(angle) * radius,
        y: Math.sin(angle) * radius,
        z: Math.random() * 3 + 0.5,
        size: 0.15 + Math.random() * 0.1,
        screenX: 0,
        screenY: 0,
        screenSize: 0
    };
}

function initCells() {
    for (let i = 0; i < NUM_CELLS; i++) {
        cells.push(createCell());
    }
}

let tunnelSpeedMod = 1;
let lookX = 0, lookY = 0;

function updateAndDrawTunnel() {
    const speed = SPEED * tunnelSpeedMod;
    
    cells.forEach(cell => {
        cell.z -= speed;
        
        if (cell.z < 0.1) {
            cell.z = 3 + Math.random();
            const angle = Math.random() * Math.PI * 2;
            const radius = 0.3 + Math.random() * 1.5;
            cell.x = Math.cos(angle) * radius;
            cell.y = Math.sin(angle) * radius;
        }
        
        const scale = 1 / cell.z;
        cell.screenX = cx + (cell.x - lookX * 0.3) * scale * 400;
        cell.screenY = cy + (cell.y - lookY * 0.3) * scale * 400;
        cell.screenSize = cell.size * scale * 300;
        
        if (cell.screenX < -100 || cell.screenX > W + 100 || 
            cell.screenY < -100 || cell.screenY > H + 100) return;
        if (cell.screenSize < 2) return;
        
        const alpha = Math.min(1, (1 - cell.z / 4) * 0.6);
        
        $.strokeStyle = `rgba(201, 162, 39, ${alpha})`;
        $.lineWidth = Math.max(1, scale * 2);
        $.beginPath();
        for (let i = 0; i < 6; i++) {
            const a = (Math.PI / 3) * i - Math.PI / 6;
            const px = cell.screenX + Math.cos(a) * cell.screenSize;
            const py = cell.screenY + Math.sin(a) * cell.screenSize;
            if (i === 0) $.moveTo(px, py);
            else $.lineTo(px, py);
        }
        $.closePath();
        $.stroke();
        
        if (cell.z < 1.5) {
            const glowAlpha = (1 - cell.z / 1.5) * 0.15;
            $.fillStyle = `rgba(201, 162, 39, ${glowAlpha})`;
            $.fill();
        }
    });
}

initCells();

// ═══════════════════════════════════════════════════════════════
// MUSICA - fluisce autonoma, senza interruzioni
// ═══════════════════════════════════════════════════════════════

const ROOT = 110;
const PROGRESSIONS = [
    [[0,4,7,11], [9,12,16,19], [5,9,12,17], [7,11,14,19]],
    [[0,4,7,11], [7,11,14,19], [9,12,16,19], [5,9,12,17]],
    [[2,5,9,12], [7,11,14,17], [0,4,7,11], [0,4,7,11]],
    [[0,4,7,11], [5,9,12,17], [9,12,16,19], [7,11,14,19]],
];
const SCALES = { major: [0,2,4,5,7,9,11], minor: [0,2,3,5,7,8,10], dorian: [0,2,3,5,7,9,10] };

let currentScale = SCALES.major;
let currentProgression = 0;
let chordIndex = 0;
let ctx, masterGain, isPlaying = false;
let padVoices = [], bassOsc;
let energy = 0.5, brightness = 0.5;

function midiToFreq(midi) { return ROOT * Math.pow(2, midi / 12); }
function quantize(degree) {
    const oct = Math.floor(degree / 12), note = ((degree % 12) + 12) % 12;
    let closest = 0, minD = 12;
    for (const s of currentScale) {
        const d = Math.min(Math.abs(s - note), 12 - Math.abs(s - note));
        if (d < minD) { minD = d; closest = s; }
    }
    return oct * 12 + closest;
}

function initAudio() {
    if (ctx) return;
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    
    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -20; comp.ratio.value = 6;
    comp.connect(ctx.destination);
    
    masterGain = ctx.createGain();
    masterGain.gain.value = 0;
    masterGain.connect(comp);
    
    const reverb = ctx.createConvolver();
    const len = ctx.sampleRate * 2;
    const imp = ctx.createBuffer(2, len, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const d = imp.getChannelData(ch);
        for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/len, 2);
    }
    reverb.buffer = imp;
    const revGain = ctx.createGain(); revGain.gain.value = 0.25;
    masterGain.connect(reverb); reverb.connect(revGain); revGain.connect(comp);
    
    masterGain.gain.setTargetAtTime(0.7, ctx.currentTime, 2);
    
    // Bass
    bassOsc = ctx.createOscillator();
    const bassGain = ctx.createGain();
    const bassFilter = ctx.createBiquadFilter();
    bassOsc.type = 'sine';
    bassFilter.type = 'lowpass'; bassFilter.frequency.value = 200;
    bassGain.gain.value = 0.2;
    bassOsc.connect(bassFilter); bassFilter.connect(bassGain); bassGain.connect(masterGain);
    bassOsc.frequency.value = midiToFreq(PROGRESSIONS[0][0][0] - 12);
    bassOsc.start();
    
    // Pad
    for (let i = 0; i < 4; i++) {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const filter = ctx.createBiquadFilter();
        osc.type = 'sawtooth';
        filter.type = 'lowpass'; filter.frequency.value = 600 + i * 150;
        gain.gain.value = 0.04;
        osc.connect(filter); filter.connect(gain); gain.connect(masterGain);
        osc.frequency.value = midiToFreq(PROGRESSIONS[0][0][i]);
        osc.start();
        padVoices.push({ osc, gain, filter });
    }
    
    // Cambio accordo regolare
    setInterval(() => {
        chordIndex = (chordIndex + 1) % 4;
        const chord = PROGRESSIONS[currentProgression][chordIndex];
        bassOsc.frequency.setTargetAtTime(midiToFreq(chord[0] - 12), ctx.currentTime, 0.3);
        padVoices.forEach((v, i) => {
            v.osc.frequency.setTargetAtTime(midiToFreq(chord[i]), ctx.currentTime, 0.4);
            v.filter.frequency.setTargetAtTime(400 + brightness * 1500, ctx.currentTime, 0.2);
        });
    }, 2500);
    
    // Arpeggio costante
    let arpIdx = 0;
    setInterval(() => {
        const chord = PROGRESSIONS[currentProgression][chordIndex];
        const pattern = [0, 2, 1, 3, 2, 0];
        const note = chord[pattern[arpIdx % pattern.length] % 4] + 12;
        playNote(note, 0.08 * energy);
        arpIdx++;
    }, 200);
    
    // Melodia generativa
    setInterval(() => {
        if (Math.random() > energy * 0.7) return;
        const chord = PROGRESSIONS[currentProgression][chordIndex];
        const note = quantize(chord[0] + 12 + Math.floor(Math.random() * 14));
        playNote(note + 12, 0.1 * energy, 0.4);
    }, 400);
    
    isPlaying = true;
}

function playNote(midi, vol, dur = 0.2) {
    if (!ctx) return;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = brightness > 0.5 ? 'triangle' : 'sine';
    osc.frequency.value = midiToFreq(midi);
    gain.gain.value = 0;
    gain.gain.linearRampToValueAtTime(vol, ctx.currentTime + 0.01);
    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + dur);
    osc.connect(gain); gain.connect(masterGain);
    osc.start(); osc.stop(ctx.currentTime + dur + 0.1);
}

// ═══════════════════════════════════════════════════════════════
// API
// ═══════════════════════════════════════════════════════════════

let API = [];
let mouse = { x: W/2, y: H/2 };

async function loadApi() {
    try {
        const txt = await fetch('ALVEARE.txt').then(r => r.text());
        txt.split('\n').filter(r => r.includes('|') && !r.startsWith('#')).forEach((r, i) => {
            const p = r.split('|').map(x => x.trim());
            if (p[1] && p[1].includes('-') && !API.find(a => a.nome === p[1])) {
                const nome = p[1];
                const hash = nome.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
                API.push({
                    nome, hash,
                    x: cx + (Math.random() - 0.5) * 300,
                    y: cy + (Math.random() - 0.5) * 300,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    size: 3 + (hash % 3),
                    hue: 38 + (hash % 15),
                    trail: []
                });
            }
        });
    } catch(e) {
        for (let i = 0; i < 35; i++) {
            API.push({
                nome: 'ape-' + i, hash: i * 17,
                x: cx + (Math.random() - 0.5) * 300,
                y: cy + (Math.random() - 0.5) * 300,
                vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                size: 3 + Math.random() * 2, hue: 38 + Math.random() * 12,
                trail: []
            });
        }
    }
}
loadApi();

// ═══════════════════════════════════════════════════════════════
// INTERAZIONE
// ═══════════════════════════════════════════════════════════════

let lastX = W/2, lastY = H/2;

onmousemove = e => {
    const speed = Math.sqrt((e.clientX - lastX) ** 2 + (e.clientY - lastY) ** 2);
    lastX = mouse.x = e.clientX;
    lastY = mouse.y = e.clientY;
    
    lookX = (e.clientX - cx) / cx;
    lookY = (e.clientY - cy) / cy;
    tunnelSpeedMod = 1 + speed * 0.02;
    
    brightness = 1 - e.clientY / H;
    energy = Math.min(1, energy * 0.95 + speed * 0.008);
};

// ═══════════════════════════════════════════════════════════════
// RENDER
// ═══════════════════════════════════════════════════════════════

function loop() {
    $.fillStyle = 'rgba(0, 0, 0, 0.12)';
    $.fillRect(0, 0, W, H);
    
    updateAndDrawTunnel();
    
    if (API.length === 0) { requestAnimationFrame(loop); return; }
    
    let avgX = 0, avgY = 0, avgVX = 0, avgVY = 0;
    API.forEach(a => { avgX += a.x; avgY += a.y; avgVX += a.vx; avgVY += a.vy; });
    avgX /= API.length; avgY /= API.length;
    avgVX /= API.length; avgVY /= API.length;
    
    API.forEach((a, i) => {
        let sepX = 0, sepY = 0;
        
        // Separazione da altre api
        API.forEach((b, j) => {
            if (i === j) return;
            const dx = a.x - b.x, dy = a.y - b.y;
            const d = Math.sqrt(dx*dx + dy*dy) || 1;
            if (d < 30) { sepX += (dx/d) * 0.5; sepY += (dy/d) * 0.5; }
        });
        
        // Evita esagoni - silenziosamente, senza drammi
        cells.forEach(cell => {
            if (cell.screenSize < 20) return;
            const dx = a.x - cell.screenX;
            const dy = a.y - cell.screenY;
            const dist = Math.sqrt(dx*dx + dy*dy) || 1;
            const avoidRadius = cell.screenSize * 1.1;
            
            if (dist < avoidRadius) {
                const force = (avoidRadius - dist) / avoidRadius * 0.4;
                sepX += (dx / dist) * force;
                sepY += (dy / dist) * force;
            }
        });
        
        a.vx += (avgVX - a.vx) * 0.02 + (avgX - a.x) * 0.001 + sepX;
        a.vy += (avgVY - a.vy) * 0.02 + (avgY - a.y) * 0.001 + sepY;
        
        const dx = mouse.x - a.x, dy = mouse.y - a.y;
        const d = Math.sqrt(dx*dx + dy*dy) || 1;
        if (d < 200) { a.vx += (dx/d) * 0.2; a.vy += (dy/d) * 0.2; }
        
        a.vx += (cx - a.x) * 0.0005;
        a.vy += (cy - a.y) * 0.0005;
        
        const v = Math.sqrt(a.vx*a.vx + a.vy*a.vy);
        const maxV = 3 + energy * 3;
        if (v > maxV) { a.vx = (a.vx/v)*maxV; a.vy = (a.vy/v)*maxV; }
        
        a.x += a.vx; a.y += a.vy;
        
        a.trail.push({ x: a.x, y: a.y });
        if (a.trail.length > 20) a.trail.shift();
    });
    
    // Connessioni
    $.lineWidth = 0.5;
    API.forEach((a, i) => {
        API.forEach((b, j) => {
            if (j <= i) return;
            const d = Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
            if (d < 70) {
                $.strokeStyle = `rgba(201, 162, 39, ${(1 - d/70) * 0.2})`;
                $.beginPath(); $.moveTo(a.x, a.y); $.lineTo(b.x, b.y); $.stroke();
            }
        });
    });
    
    // Trail e api
    API.forEach(a => {
        if (a.trail.length > 2) {
            $.beginPath();
            $.moveTo(a.trail[0].x, a.trail[0].y);
            a.trail.forEach(p => $.lineTo(p.x, p.y));
            $.strokeStyle = `hsla(${a.hue}, 60%, 55%, 0.3)`;
            $.lineWidth = 2;
            $.stroke();
        }
        
        const grad = $.createRadialGradient(a.x, a.y, 0, a.x, a.y, a.size * 5);
        grad.addColorStop(0, `hsla(${a.hue}, 70%, 60%, 0.4)`);
        grad.addColorStop(1, 'transparent');
        $.fillStyle = grad;
        $.beginPath();
        $.arc(a.x, a.y, a.size * 5, 0, Math.PI * 2);
        $.fill();
        
        $.fillStyle = `hsla(${a.hue}, 70%, 65%, 0.95)`;
        $.beginPath();
        $.arc(a.x, a.y, a.size, 0, Math.PI * 2);
        $.fill();
    });
    
    requestAnimationFrame(loop);
}

document.getElementById('start').onclick = () => {
    initAudio();
    document.getElementById('start').classList.add('hidden');
};

requestAnimationFrame(loop);
</script>
</body>
</html>