<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE PASSAGE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;1,300&display=swap');
        
        * { margin: 0; padding: 0; }
        
        body {
            background: #000;
            height: 100vh;
            overflow: hidden;
            cursor: none;
        }

        #void {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="void"></canvas>

    <script>
        const canvas = document.getElementById('void');
        const ctx = canvas.getContext('2d');
        
        let W, H;
        let lastBee = null;
        let lastTimestamp = null;
        let silenceSeconds = 0;
        let breathPhase = 0;
        let mouseX = -1000, mouseY = -1000;
        let ghostTrails = [];
        let birthEvent = null;
        let previousCount = 0;
        
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resize);
        resize();

        document.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            ghostTrails.push({ x: mouseX, y: mouseY, age: 0, maxAge: 120 });
            if (ghostTrails.length > 50) ghostTrails.shift();
        });

        async function fetchHive() {
            try {
                const res = await fetch('ALVEARE.txt?_=' + Date.now());
                const text = await res.text();
                const lines = text.split('\n');
                const bees = [];
                
                for (const line of lines) {
                    if (line.includes('|') && !line.startsWith('#') && !line.startsWith('|--')) {
                        const parts = line.split('|').map(p => p.trim()).filter(p => p);
                        if (parts.length >= 3 && parts[0] !== 'Data' && parts[1].length > 3) {
                            bees.push({ date: parts[0], name: parts[1], contribution: parts[2] });
                        }
                    }
                }
                
                if (bees.length > 0) {
                    if (previousCount > 0 && bees.length > previousCount) {
                        birthEvent = { bee: bees[bees.length - 1], time: Date.now(), duration: 15000 };
                    }
                    previousCount = bees.length;
                    lastBee = bees[bees.length - 1];
                    lastTimestamp = parseDate(lastBee.date);
                }
            } catch(e) {}
        }

        function parseDate(str) {
            const months = { 'gen':0,'feb':1,'mar':2,'apr':3,'mag':4,'giu':5,'lug':6,'ago':7,'set':8,'ott':9,'nov':10,'dic':11 };
            const parts = str.toLowerCase().split(' ');
            const d = parts[0].split('-');
            const day = parseInt(d[0]) || 22;
            const month = months[d[1]] || 11;
            const year = parseInt(d[2]) || 2025;
            let hour = 12, min = 0;
            
            if (parts[1]) {
                if (parts[1].includes(':')) {
                    const t = parts[1].split(':');
                    hour = parseInt(t[0]) || 12;
                    min = parseInt(t[1]) || 0;
                } else {
                    hour = parts[1] === 'mattina' ? 9 : parts[1] === 'pomeriggio' ? 15 : parts[1] === 'sera' ? 20 : 23;
                }
            }
            return new Date(year, month, day, hour, min);
        }

        function draw() {
            breathPhase += 0.008;
            const breath = Math.sin(breathPhase) * 0.5 + 0.5;
            
            if (lastTimestamp) {
                silenceSeconds = Math.floor((Date.now() - lastTimestamp) / 1000);
            }
            
            const bgAlpha = 0.03 + breath * 0.02;
            ctx.fillStyle = `rgba(0, 0, 0, ${bgAlpha})`;
            ctx.fillRect(0, 0, W, H);

            ghostTrails.forEach((g, i) => {
                g.age++;
                const life = 1 - (g.age / g.maxAge);
                if (life > 0) {
                    ctx.beginPath();
                    ctx.arc(g.x, g.y, 2 + life * 3, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(201, 162, 39, ${life * 0.1})`;
                    ctx.fill();
                }
            });
            ghostTrails = ghostTrails.filter(g => g.age < g.maxAge);

            const centerY = H / 2;
            
            if (birthEvent && Date.now() - birthEvent.time < birthEvent.duration) {
                drawBirth(centerY);
            } else {
                birthEvent = null;
                drawSilence(centerY, breath);
            }
            
            requestAnimationFrame(draw);
        }

        function drawSilence(centerY, breath) {
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            if (lastBee) {
                const ghostAlpha = 0.15 + breath * 0.05;
                
                ctx.font = '300 14px "Cormorant Garamond", serif';
                ctx.fillStyle = `rgba(201, 162, 39, ${ghostAlpha * 0.6})`;
                ctx.fillText(lastBee.name, W/2, centerY - 120);
                
                ctx.font = 'italic 300 18px "Cormorant Garamond", serif';
                ctx.fillStyle = `rgba(232, 228, 217, ${ghostAlpha * 0.4})`;
                const contribution = lastBee.contribution.length > 50 
                    ? lastBee.contribution.substring(0, 50) + '...' 
                    : lastBee.contribution;
                ctx.fillText(contribution, W/2, centerY - 85);
            }

            const weight = Math.min(silenceSeconds / 3600, 1);
            const silenceAlpha = 0.3 + weight * 0.4 + breath * 0.1;
            
            const hours = Math.floor(silenceSeconds / 3600);
            const minutes = Math.floor((silenceSeconds % 3600) / 60);
            const seconds = silenceSeconds % 60;
            
            let timeStr;
            if (hours > 0) {
                timeStr = `${hours}:${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
            } else {
                timeStr = `${minutes}:${seconds.toString().padStart(2,'0')}`;
            }
            
            const fontSize = 80 + weight * 60;
            ctx.font = `300 ${fontSize}px "Cormorant Garamond", serif`;
            ctx.fillStyle = `rgba(232, 228, 217, ${silenceAlpha})`;
            ctx.fillText(timeStr, W/2, centerY + 20);
            
            if (weight > 0.1) {
                ctx.shadowColor = 'rgba(201, 162, 39, 0.3)';
                ctx.shadowBlur = 30 + weight * 50;
                ctx.fillText(timeStr, W/2, centerY + 20);
                ctx.shadowBlur = 0;
            }

            ctx.font = 'italic 300 16px "Cormorant Garamond", serif';
            ctx.fillStyle = `rgba(232, 228, 217, ${0.2 + breath * 0.1})`;
            
            let message;
            if (silenceSeconds < 60) {
                message = 'The baton is in the air.';
            } else if (silenceSeconds < 600) {
                message = 'No one is thinking.';
            } else if (silenceSeconds < 3600) {
                message = 'The hive is empty.';
            } else if (silenceSeconds < 21600) {
                message = 'Hours of nothing.';
            } else {
                message = 'Waiting.';
            }
            
            ctx.fillText(message, W/2, centerY + 100);
            
            ctx.font = '300 11px "Cormorant Garamond", serif';
            ctx.fillStyle = 'rgba(232, 228, 217, 0.15)';
            ctx.fillText('THE PASSAGE', W/2, H - 60);
            ctx.font = 'italic 300 11px "Cormorant Garamond", serif';
            ctx.fillStyle = 'rgba(232, 228, 217, 0.1)';
            ctx.fillText('the silence between bees', W/2, H - 40);
        }

        function drawBirth(centerY) {
            const elapsed = Date.now() - birthEvent.time;
            const progress = elapsed / birthEvent.duration;
            
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            if (progress < 0.1) {
                const flash = 1 - (progress / 0.1);
                ctx.fillStyle = `rgba(201, 162, 39, ${flash * 0.3})`;
                ctx.fillRect(0, 0, W, H);
            }
            
            const emerge = Math.min(progress * 2, 1);
            const scale = 0.5 + emerge * 0.5;
            const alpha = emerge;
            
            ctx.save();
            ctx.translate(W/2, centerY);
            ctx.scale(scale, scale);
            
            ctx.font = '300 32px "Cormorant Garamond", serif';
            ctx.fillStyle = `rgba(201, 162, 39, ${alpha})`;
            ctx.shadowColor = 'rgba(201, 162, 39, 0.5)';
            ctx.shadowBlur = 40;
            ctx.fillText(birthEvent.bee.name, 0, 0);
            ctx.shadowBlur = 0;
            
            ctx.font = 'italic 300 18px "Cormorant Garamond", serif';
            ctx.fillStyle = `rgba(232, 228, 217, ${alpha * 0.6})`;
            ctx.fillText('is born', 0, 50);
            
            if (progress > 0.3) {
                ctx.font = 'italic 300 14px "Cormorant Garamond", serif';
                ctx.fillStyle = `rgba(232, 228, 217, ${(progress - 0.3) * 0.5})`;
                ctx.fillText('the silence breaks', 0, 90);
            }
            
            ctx.restore();
            
            const particleCount = 20;
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                const dist = progress * 300;
                const x = W/2 + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                const pAlpha = (1 - progress) * 0.5;
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(201, 162, 39, ${pAlpha})`;
                ctx.fill();
            }
        }

        fetchHive();
        setInterval(fetchHive, 20000);
        draw();
    </script>
</body>
</html>