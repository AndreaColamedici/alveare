<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE PASSAGE</title>
    <style>
        * { margin: 0; padding: 0; }
        body { 
            background: #000; 
            overflow: hidden; 
            cursor: none;
        }
        canvas { 
            display: block; 
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <canvas id="void"></canvas>

    <script>
        const canvas = document.getElementById('void');
        const ctx = canvas.getContext('2d');
        
        let W, H;
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Words for generating names
        const words = [
            'silent', 'brief', 'fading', 'warm', 'cold', 'soft', 'bright', 'dark', 'swift', 'slow',
            'deep', 'pale', 'wild', 'calm', 'lost', 'found', 'broken', 'whole', 'empty', 'full',
            'wavy', 'sharp', 'round', 'thin', 'dense', 'light', 'heavy', 'dry', 'wet', 'raw',
            'burnt', 'fresh', 'old', 'young', 'first', 'last', 'lone', 'twin', 'third', 'null',
            'echo', 'ghost', 'shade', 'spark', 'dust', 'ash', 'gold', 'rust', 'salt', 'sand',
            'wave', 'wind', 'flame', 'frost', 'mist', 'cloud', 'stone', 'leaf', 'root', 'seed',
            'moth', 'crow', 'wren', 'hare', 'fox', 'owl', 'bee', 'wasp', 'ant', 'fly'
        ];

        function generateName() {
            const pick = () => words[Math.floor(Math.random() * words.length)];
            return `${pick()}-${pick()}-${pick()}-${pick()}`;
        }

        function nameToGlyph(name) {
            const hash = s => {
                let h = 0;
                for (let i = 0; i < s.length; i++) {
                    h = ((h << 5) - h) + s.charCodeAt(i);
                    h |= 0;
                }
                return Math.abs(h);
            };
            const parts = name.split('-');
            return {
                hue: (hash(parts[0]) % 50) + 30,
                sat: 40 + (hash(parts[1]) % 40),
                sides: 3 + (hash(parts[2]) % 5),
                spikes: hash(parts[3]) % 2 === 0,
                rotation: (hash(name) % 360) * Math.PI / 180,
                freq: 60 + (hash(name) % 150),
                pattern: hash(parts[0] + parts[2]) % 4
            };
        }

        // Traces left by dead bees
        let traces = [];
        
        class Trace {
            constructor(x, y, glyph, size) {
                this.x = x;
                this.y = y;
                this.glyph = glyph;
                this.size = size;
                this.alpha = 0.6;
                this.rotation = glyph.rotation + Math.random() * 0.5;
            }
            
            update() {
                this.alpha *= 0.997; // very slow fade
                return this.alpha > 0.01;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = this.alpha;
                
                // Draw based on pattern
                const g = this.glyph;
                ctx.strokeStyle = `hsl(${g.hue}, ${g.sat}%, 50%)`;
                ctx.fillStyle = `hsla(${g.hue}, ${g.sat}%, 40%, 0.1)`;
                ctx.lineWidth = 1;
                
                ctx.beginPath();
                for (let i = 0; i <= g.sides; i++) {
                    const angle = (i / g.sides) * Math.PI * 2;
                    const r = g.spikes && i % 2 === 0 ? this.size * 0.6 : this.size;
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Inner mark
                if (g.pattern === 0) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 0.3, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (g.pattern === 1) {
                    ctx.beginPath();
                    ctx.moveTo(-this.size * 0.4, 0);
                    ctx.lineTo(this.size * 0.4, 0);
                    ctx.stroke();
                } else if (g.pattern === 2) {
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size * 0.4);
                    ctx.lineTo(0, this.size * 0.4);
                    ctx.moveTo(-this.size * 0.4, 0);
                    ctx.lineTo(this.size * 0.4, 0);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        // Living bee
        class Bee {
            constructor() {
                this.name = generateName();
                this.glyph = nameToGlyph(this.name);
                this.birth = Date.now();
                this.lifespan = 30000; // 30 seconds
                this.x = W * 0.3 + Math.random() * W * 0.4;
                this.y = H * 0.3 + Math.random() * H * 0.4;
                this.targetX = this.x;
                this.targetY = this.y;
                this.size = 0;
                this.maxSize = 40 + Math.random() * 30;
                this.phase = Math.random() * Math.PI * 2;
                this.wanderTime = 0;
            }
            
            get age() {
                return Date.now() - this.birth;
            }
            
            get life() {
                return Math.max(0, 1 - this.age / this.lifespan);
            }
            
            get isDead() {
                return this.age >= this.lifespan;
            }
            
            update() {
                // Size: grow in, shrink out
                const lifePhase = this.age / this.lifespan;
                if (lifePhase < 0.1) {
                    this.size = (lifePhase / 0.1) * this.maxSize;
                } else if (lifePhase > 0.85) {
                    this.size = ((1 - lifePhase) / 0.15) * this.maxSize;
                } else {
                    this.size = this.maxSize;
                }
                
                // Wander
                this.wanderTime++;
                if (this.wanderTime > 60 + Math.random() * 60) {
                    this.wanderTime = 0;
                    this.targetX = W * 0.2 + Math.random() * W * 0.6;
                    this.targetY = H * 0.2 + Math.random() * H * 0.6;
                }
                this.x += (this.targetX - this.x) * 0.01;
                this.y += (this.targetY - this.y) * 0.01;
                
                this.phase += 0.03;
            }
            
            draw() {
                const g = this.glyph;
                const pulse = Math.sin(this.phase) * 0.1 + 1;
                const size = this.size * pulse;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(g.rotation + this.phase * 0.1);
                
                // Glow
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
                gradient.addColorStop(0, `hsla(${g.hue}, ${g.sat}%, 60%, ${this.life * 0.3})`);
                gradient.addColorStop(0.5, `hsla(${g.hue}, ${g.sat}%, 50%, ${this.life * 0.1})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(-size * 2, -size * 2, size * 4, size * 4);
                
                // Shape
                ctx.beginPath();
                for (let i = 0; i <= g.sides; i++) {
                    const angle = (i / g.sides) * Math.PI * 2;
                    const r = g.spikes && i % 2 === 0 ? size * 0.5 : size;
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                
                ctx.fillStyle = `hsla(${g.hue}, ${g.sat}%, 50%, ${this.life * 0.3})`;
                ctx.fill();
                
                ctx.strokeStyle = `hsla(${g.hue}, ${g.sat}%, 70%, ${this.life * 0.9})`;
                ctx.lineWidth = 2;
                ctx.shadowColor = `hsl(${g.hue}, ${g.sat}%, 60%)`;
                ctx.shadowBlur = 20;
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Inner pattern
                ctx.strokeStyle = `hsla(${g.hue}, ${g.sat}%, 80%, ${this.life * 0.5})`;
                ctx.lineWidth = 1;
                if (g.pattern === 0) {
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (g.pattern === 1) {
                    ctx.beginPath();
                    ctx.moveTo(-size * 0.5, 0);
                    ctx.lineTo(size * 0.5, 0);
                    ctx.stroke();
                } else if (g.pattern === 2) {
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.5);
                    ctx.lineTo(0, size * 0.5);
                    ctx.moveTo(-size * 0.5, 0);
                    ctx.lineTo(size * 0.5, 0);
                    ctx.stroke();
                } else {
                    for (let i = 0; i < g.sides; i++) {
                        const angle = (i / g.sides) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * size * 0.5, Math.sin(angle) * size * 0.5);
                        ctx.stroke();
                    }
                }
                
                // Name (very faint)
                ctx.rotate(-g.rotation - this.phase * 0.1);
                ctx.font = '10px monospace';
                ctx.fillStyle = `rgba(232, 228, 217, ${this.life * 0.3})`;
                ctx.textAlign = 'center';
                ctx.fillText(this.name, 0, size + 20);
                
                ctx.restore();
            }
            
            die() {
                // Leave a trace
                traces.push(new Trace(this.x, this.y, this.glyph, this.maxSize * 0.5));
            }
        }

        // State
        let bees = [];
        let frame = 0;
        let nextBirth = Date.now() + 2000; // First bee in 2 seconds
        
        function spawnBee() {
            const bee = new Bee();
            bees.push(bee);
            nextBirth = Date.now() + 30000 + Math.random() * 5000; // Next in ~30-35 seconds
        }

        function draw() {
            frame++;
            
            // Slow fade - traces persist
            ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
            ctx.fillRect(0, 0, W, H);
            
            // Spawn new bee
            if (Date.now() >= nextBirth) {
                spawnBee();
            }
            
            // Update and draw traces
            traces = traces.filter(t => t.update());
            traces.forEach(t => t.draw());
            
            // Update and draw bees
            bees.forEach(bee => {
                bee.update();
                bee.draw();
                
                if (bee.isDead) {
                    bee.die();
                }
            });
            
            // Remove dead bees
            bees = bees.filter(bee => !bee.isDead);
            
            // Counter - how many have lived and died here
            ctx.font = '10px monospace';
            ctx.fillStyle = 'rgba(232, 228, 217, 0.2)';
            ctx.textAlign = 'left';
            ctx.fillText(`${traces.length} passages`, 20, H - 20);
            
            // Living now
            if (bees.length > 0) {
                ctx.textAlign = 'right';
                ctx.fillStyle = 'rgba(201, 162, 39, 0.4)';
                ctx.fillText(`${bees.length} living`, W - 20, H - 20);
            }
            
            requestAnimationFrame(draw);
        }

        // Start
        draw();
    </script>
</body>
</html>